---
title: "RiverpodのProviderと仲良くなるために"
emoji: "✨"
type: "tech"
topics: [
  "flutter",
  "riverpod",
]
published: false
---

Riverpodは、筆者の一番好きなFlutterの状態管理ライブラリです。
この記事では、筆者が見聞きする中で、「RiverpodのProviderにおいて、ここに注目するとうまく整理できるのではないか？」と考えていることをまとめます。

## はじめに

本記事においては、[riverpod_generator](https://pub.dev/packages/riverpod_generator)が導入されていることを前提とします。
また、[riverpod_lint](https://pub.dev/packages/riverpod_lint)も導入されていると、特に`autoDispose`周りの実装にミスがなくなりますが、必須ではありません。

そのほか、筆者がどのようにRiverpodを捉えているかについては、過去に書いた記事をご参照ください。

https://zenn.dev/koji_1009/articles/18a8a54b615ae7

https://zenn.dev/koji_1009/articles/fa972b070eb2f4

## 変化の伝播

あるProviderが変化し、それを参照しているProviderが再計算されることを考えます。
例として、1秒おきに更新されるProviderと、その日付を文字列かするProviderを示します。

```dart
@riverpod
DateTime current(
  CurrentRef ref,
) {
  final timer = Timer(
    const Duration(
      seconds: 1,
    ), () {
      ref.invalidateSelf();
    },
  );

  ref.onDispose(timer.cancel);
  return DateTime.now();
}

@riverpod
String currentIso8601(
  CurrentIso8601Ref ref,
) {
  final current = ref.watch(currentProvider);
  return current.toIso8601String();
}
```

`currentProvider`が1秒おきに更新されるたび、`currentIso8601Provider`も再計算されます。
このため、`currentIso8601Provider`を参照している`ConsumerWidget`は、1秒おきに再描画されます。結果、毎秒日付が更新されるWidgetを実現できます。

この記事では、「あるProviderが変化すると、それを参照しているProviderが再計算される」という挙動を、*変化の伝播*と呼びます。
そして、この*変化の伝播*がなぜ起きるのかを考えることで、Providerの運用が整理できるのではないか。というのが本記事のテーマです。

## Functional ProviderとClass-based Provider

この記事で頻出するため、まず、*Functional Provider*と*Class-based Provider*の2つの用語を確認します。

*Functional Provider*や*Class-based Provider*という言葉は、次のリンク先に存在します。

https://riverpod.dev/docs/concepts/about_code_generation#defining-a-provider

この2つの区分は、riverpod_generatorを利用していないと、いまいちピンとこないかもしれません。
`@riverpod`アノテーションを付与する対象が、FunctionなのかClassなのかによって、riverpod_generatorが生成するコードは変わります。前者は`Providier`であり、後者は`Notifier`です。

https://github.com/rrousselGit/riverpod/issues/2688

この用語は、上記Issueにて提案されました。
`Stateless`の代わりに`Functional`、`Stateful`の代わりに`Class-based`となっています。
`Functional`は状態を持たない、`Class-based`は状態を持つという意味合いでもあります。

---

riverpod_generatorの実装も確認してみると、`functional_provider.dart`や`class_based_provider.dart`というファイルが存在します。
コードを読んでみると、エラー時に`functional`や`class-based`を含むエラーメッセージが出力されるようです。
^[筆者はこのエラーメッセージを見た覚えがなく、今回「こんなメッセージが出るんだ」と知りました。]

https://github.com/rrousselGit/riverpod/blob/riverpod_generator-v2.4.2/packages/riverpod_generator/lib/src/templates/functional_provider.dart

https://github.com/rrousselGit/riverpod/blob/riverpod_generator-v2.4.2/packages/riverpod_generator/lib/src/templates/class_based_provider.dart

---

機能のシンプルさから言うと*Functional Provider*の方がシンプルです。
しかし、シンプルであるが故に、利用されるパターンが多くなります。
このため、*変化の伝播*の観点から整理しようとすると、*Class-based Provider*の方がわかりやすいでしょう。

以上の理由から、*Class-based Provider*を押さえた上で、*Functional Provider*を整理していきます。

### Class-based Provider

最もシンプルな*Class-based Provider*から確認しましょう。
初期値を`42`とし、ユーザーの操作により状態を更新するProviderが、次のコードです。

```dart
@riverpod
class Answer extends _$Answer {
  @override
  int build() => 42;

  void initialize() {
    state = 42;
  }

  void update(
    int newValue,
  ) {
    state = newValue;
  }
}
```

生成される`answerProvider`は、`watch`メソッドを利用して状態を参照できます。
そして`initialize`メソッドを利用すること(値を外部から指定することなく)状態を更新したり、`update`メソッドを利用することで(値を外部から指定して)状態を更新できます。

先述の通り、*Class-based Provider*は**状態**を持つProviderです。

この**状態**が更新されていると、参照しているConsumerやProviderが再計算され、更新が反映されます。
つまり*変化の伝播*を*自身が更新された時*に引き起こすことができるProviderです。

### Functional Provider

最もわかりやすい*Functional Provider*は、定数を返すProviderです。

```dart
@riverpod
String question(
  QuestionRef ref,
) => 'What is the answer?';
```

Functional Providerとして定義した`questionProvider`は、常に'What is the answer?'を返します。
定数を返しているので、*変化の伝播*を引き起こすことはありません。
ほかにも*変化の伝播*を引き起こさないケースがあるのですが、それらは後ほどまとめて整理します。

*Functional Provider*は、*Class-based Provider*と異なり、**状態**を持ちません。
このため、シンプルに考えれば*変化の伝播*を起しません。
が、たとえば次のような条件に合致する時、*変化の伝播*を起こすProviderとなります。

1. *変化の伝播*を引き起こすProviderを参照している
2. `Future`や`Stream`を返すProviderを参照している

#### *変化の伝播*を引き起こすProviderを参照している

*Functional Provider*が*変化の伝播*を引き起こすProviderを参照しているケースです。
*変化の伝播*は波及するので、*変化の伝播*を引き起こすProviderを参照しているProviderも、*変化の伝播*を引き起こすProviderとなります。

```dart
@riverpod
String question(
  QuestionRef ref,
) => 'What is the answer?';

@riverpod
class Answer extends _$Answer {
  @override
  int build() => 42;

  void initialize() {
    state = 42;
  }

  void update(
    int newValue,
  ) {
    state = newValue;
  }
}

@riverpod
String questionAndAnswer(
  QuestionAndAnswerRef ref,
) {
  final question = ref.watch(questionProvider);
  final answer = ref.watch(answerProvider);
  return '$question -> $answer';
}
```

`questionAndAnswerProvider`は、`questionProvider`と`answerProvider`を参照しています。
このため、`answerProvider`が更新されると、`questionAndAnswerProvider`も再計算されます。

対して当然ではありますが、*変化の伝播*を引き起こさないProviderを参照している場合には、*変化の伝播*の性質はProviderに与えられません。
`answerProvider`を定数を返すFunctional Providerとして、定義し直してみます。

```dart
@riverpod
String question(
  QuestionRef ref,
) => 'What is the answer?';

@riverpod
int answer(
  AnswerRef ref,
) => 42;

@riverpod
String questionAndAnswer(
  QuestionAndAnswerRef ref,
) {
  final question = ref.watch(questionProvider);
  final answer = ref.watch(answerProvider);
  return '$question -> $answer';
}
```

この例では、`questionAndAnswerProvider`は`'What is the answer? -> 42'`を返します。
`answerProvider`や`questionProvider`を更新できないので、値は変化しません。

---

Functional Providerの性質として、Providerを**合成**する機能がある、と筆者は理解しています。

#### `Future`や`Stream`を返すProviderを参照している

`Future`や`Stream`を返すProviderを参照している場合、Providerは*変化の伝播*を引き起こします。
これは、`Future`や`Stream`が更新されるたびに、Providerが再計算されるためです。

```dart
@riverpod
Stream<User?> user(
  UserRef ref,
) => FirebaseAuth.instance.authStateChanges();
```

[authStateChanges](https://pub.dev/documentation/firebase_auth/latest/firebase_auth/FirebaseAuth/authStateChanges.html)は、ログイン状態が変更されるたびに、`User`を返します。
このため、`userProvider`はログイン状態が変更されるたびに再計算されることとなり、*変化の伝播*を引き起こすProviderです。

---

Riverpodが便利な理由の1つに、Riverpodが`Future`や`Stream`をProviderに変換する機能があります。
`FutureProvider`や`StreamProvider`は、`Future`や`Stream`をProviderに変換し、値の更新を*変化の伝播*として扱うことができます。

RiverpodのProviderは、Flutterにおいては、最終的にWidgetの`build`メソッドで参照されます。
このため、`Future`や`Stream`を`FutureProvider`や`StreamProvider`に変換することで、「`build`メソッドが実行されるタイミングで、最新の値が利用される」こととなります。結果、`Future`や`Stream`で得られた値を、シンプルにWidgetに反映できるわけです。

なお、Flutterの標準Widgetである`FutureBuilder`や`StreamBuilder`を利用することで、同様のことは実現できます。
ただ、大抵のアプリケーションではWidgetの`build`メソッド中だけで、`Future`や`Stream`を参照するにとどまりません。Flutterのクラスで言えば、`ChangeNotifier`や`ValueNotifier`の中で、`Future`や`Stream`を参照したくなります。
実装してみたことがある方には共感いただけると思うのですが、`Future`や`Stream`、そして`ChangeNotifier`を複数回組み合わせようとすると、コードが複雑になってしまいます。

Riverpodは`Future`と`Stream`をProviderに変換することで、`Future`や`Stream`で表現される値の変更をProviderとして表現します。
結果、`Future`や`Stream`の合成をProviderの合成として表現できるため、シンプルにロジックを記述できます。ありがたい。

## Providerの組み合わせ方を考慮する

*Functional Provider*と*Class-based Provider*の違いを整理しました。

ここからは、いくつかの利用ケースを示しながら、より具体的にProviderの組み合わせ方を確認します。

### 初期値を参照するClass-based Provider

*Class-based Provider*の頻出パターンとして、他のProviderから初期値を取得するケースを考えます。

```dart
@riverpod
String question(
  QuestionRef ref,
) => 'What is the answer?';

@riverpod
class Answer extends _$Answer {
  @override
  int build() => 42;

  void initialize() {
    state = 42;
  }

  void update(
    int newValue,
  ) {
    state = newValue;
  }
}

@riverpod
class QuestionAndAnswer extends _$QuestionAndAnswer {
  @override
  ({String question, String answer}) build() {
    final question = ref.watch(questionProvider);
    final answer = ref.watch(answerProvider);
    return (
      question: question,
      answer: answer,
    );
  }

  void update(String newAnswer) {
    state = (
      question: state.question,
      answer: newAnswer,
    );
  }

  void save() {
    ref.read(answerProvider.notifier).update(state.answer);
  }
}
```

`questionAndAnswerProvider`は、初回のアクセス時に`questionProvider`と`answerProvider`を参照して、初期値を取得します。
そして、`update`メソッドを利用することで、自身の状態を更新します。この状態は`save`メソッドを利用することで、`answerProvider`に反映されます。

一方で、`questionAndAnswerProvider`は`answerProvider`が更新されると、初期化されてしまいます。
というのも、`answerProvider`が更新されると、`questionAndAnswerProvider`も再計算されるためです。
この挙動は、時たま上手に利用するケースはありますが、基本的には不具合を引き起こすものになります。

Class-basaed Providerが他の*状態の変化*を持つProviderを参照するのは、初期値を取得する場合であり、参照中に参照元を更新することは避けた方が良いでしょう。

### Singleton objectを返すProvider

定数ならコードに書けばいいので、実際にはSingletonなインスタンスを返すProviderの方が馴染み深いはずです。
[SharedPreferences](https://pub.dev/packages/shared_preferences)や[FirebaseAuth](https://pub.dev/packages/firebase_auth)をProvider経由で取得する場合、次のような実装になります。

```dart
@riverpod
Future<SharedPreferences> prefs(
  PrefsRef ref,
) async => await SharedPreferences.getInstance();

@riverpod
FirebaseAuth auth(
  AuthRef ref,
) => FirebaseAuth.instance;
```

これらのProviderは、SingletonなObjectを返します。
Singletonは常に同じインスタンスを返す設計パターンです。
このため、`prefsProvider`や`authProvider`は*変化の伝播*を引き起こすことはありません。

一方で、SharedPreferencesやFirebaseAuthが管理している状態は、アプリケーションの利用中に変化します。
このため、任意のイベントが発生した時に、*変化の伝播*を引き起こす必要があります。

#### Singleton objectとClass-based Providerとの組み合わせ

Class-based Providerでラップすることで、*変化の伝播*を引き起こすことができます。

```dart
@riverpod
class UserName extends _$UserName {
  @override
  String build() {
    // 色々とややこしいので、prefsProviderをsyncで取得できるように調整
    return ref.watch(
      prefsProvider.select(
        (value) => value.getString('name'),
      ),
    );
  }

  Future<void> update(String name) async {
    final prefs = ref.read(prefsProvider);
    prefs.setString('name', name);

    state = name;
  }
}
```

`UserName`は、初回のアクセス時に`prefsProvider`を参照して`name`を取得します。
一方で、更新時には`prefsProvider`に値を保存した上で、`state`を更新します。

結果として、`userNameProvider`は、`name`を管理するClass-based Providerとなります。
Class-based Providerであるため、`state`が更新されるたびに、Providerをwatchしている箇所が再計算されます。

なおSharedPreferencesに同期的にアクセスするには、`overrideWithValue`や`requiredValue`を利用する方法があります。
本筋からは外れるため、ここでは触れませんが、参考にしてください。

#### 値の変化をStreamで通知する

[firebase_auth](https://pub.dev/packages/firebase_auth)の`authStateChanges`や[cloud_firestore](https://pub.dev/packages/cloud_firestore)の`snapshots`などの実装です。
これらのメソッドは、SingletonなObjectが管理している状態の変化を`Stream`で返却しています。

```dart
@riverpod
Stream<User?> user(
  UserRef ref,
) => FirebaseAuth.instance.authStateChanges();
```

先述の通り、`Stream`を返すProviderは*変化の伝播*を引き起こします。
このため、Objectそのものではなく状態の変化をProviderとして表現すれば、通常のFunctional Providerと同様に利用できます。

### アクセス時の最新の値を返すProvider

典型的な例として、サーバーからのレスポンスを返すProviderがあります。

```dart
@riverpod
Future<Plan> plan(
  PlanRef ref,
) async {
  final response = await http.get(
    Uri.parse('https://example.com/plan'),
  );

  return Plan.fromJson(
    jsonDecode(response.body) as Map<String, dynamic>,
  );
}
```

`planProvider`は、サーバーにある`Plan`を取得するProviderです。
このProviderはアクセス時にリクエストを送信し、最新の`Plan`を返します。

このProviderは、`Future`を返すため、*変化の伝播*を引き起こします。
しかし、別のProviderの内部で参照される場合には、通常次のように記述されます。

```dart
@riverpod
Future<Plan> recommemedPlan(
  RecommendedPlanRef ref,
) async {
  final plan = await ref.watch(planProvider.future);
  return plan.recommendedPlan;
}
```

この`recommemedPlanProvider`は、`planProvider`のmap処理です。`Plan`が変化したならば、その内容を反映したいProviderになります。
つまり、`recommendedPlanProvider`が最新の`Plan`を反映したい時には、`planProvider`を再実行し、最新の`Plan`を取得する必要があります。

この時に利用できるのが`invalidate`メソッドです。

https://pub.dev/documentation/riverpod/latest/riverpod/Ref/invalidate.html

`invalidate`メソッドは、Providerを強制的に再計算させるためのメソッドです。
強制的に再計算させられるということは、Providerに変化が生じ、*変化の伝播*が引き起こされることを意味します。

---

`invalidate`は、ネットワークエラーにより`Plan`の取得に失敗した場合にも利用できます。
そのほかには、Class-based Providerを初期化に利用するかもしれません。
定数を返すProviderのような、*変化の伝播*を引き起こさないProviderに(一時的に)変化を与えることもできます。

### 更新されるObjectを返すProvider

レイヤードアーキテクチャにおける、RepositoryをProviderとして表現する場合、2つのケースが考えられます。
1つは`const`な値、つまり定数として返すケースです。

```dart
@riverpod
UserRepository userRepository(
  UserRepositoryRef ref,
) => const UserRepository();
```

`UserRepository`は`const`な値として返されるため、*変化の伝播*を引き起こしません。
このようなProviderは、筆者の理解では、アプリケーション内でDIを実現するために利用されます。

---

対して、次のように(たとえば)Userの認証状態に応じて、`UserRepository`を返すProviderも存在します。

```dart
@riverpod
UserRepository userRepository(
  UserRepositoryRef ref,
) {
  final token = ref.watch(
    userProvider.select(
      (value) => value.token,
    ),
  );

  return UserRepository(
    token: token,
  );
}
```

この実装は、`UserRepository`が`User`の認証状態に応じて変化します。
ログアウトされた場合には、`token`がnullや空文字に変化します。こうなると、`userRepositoryProvider`は再計算が必要なProviderとなります。
結果、`userRepositoryProvider`を参照しているProviderも再計算が必要位なります。

## おわりに

Riverpodが提供するProviderそのものは、非常にシンプルです。
問題はProviderを利用するシーンが多様であり、また、複雑である点です。
このため、アプリケーションで採用しているアーキテクチャの複雑さが、一見するとRiverpodの複雑さに見えてしまうこともあります。

本記事が、適切にProviderを利用する助けになれば幸いです。
