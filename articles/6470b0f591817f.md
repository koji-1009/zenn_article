---
title: "Riverpod v3とrefと非同期処理に向き合う"
emoji: "⚓️"
type: "tech"
topics: ["flutter", "riverpod"]
published: true
published_at: "2026-02-03 07:00"
---

## はじめに

https://pub.dev/packages/riverpod

Riverpod v3のリリースから3〜4ヶ月経ち、また[analyzer](https://pub.dev/packages/analyzer)のアップデート対応のためにバージョンアップを検討している方も多いのではないでしょうか？ ^[riverpod_generatorがanalyzerに依存しているため。]

v3はv2に比べると、特に**参照が切れたProvider**の検知が強化されました。結果として、不要なProviderが破棄されやすくなっています。このためbuildメソッド内で`ref.watch`を利用している箇所には影響がないものの、Buttonの`onPressed`内で`ref.read`を利用している箇所に影響が出ることがあります。

この記事では、特に`ref.read`で非同期処理を参照する時の実装について現在考えていることをまとめます。また、最近考えている「StatelessなSingletonは`keepAlive`してもよいのでは？」という点についても触れたいと思います。

なお、すべて筆者が調べたり考えたりした内容です。もし間違った情報や、より良い実装方法があれば、お知らせください。

## `ref.read`と非同期処理

Riverpodは、Dartのプロジェクト一般で利用できるライブラリです。そのうちFlutterでは、**Widgetのビルドサイクルに合わせて不要なProviderを破棄する**設計になっています。

このため、あらゆる場面でフレームを踏まえて考える必要が生じます。特に、処理は**1フレーム以内に完結するか**が、重要なポイントです。画面遷移を挟んだケースでも、遷移前と後でフレームを跨いだために参照しようとしたProviderが破棄された、なんてことも起こります。とはいえ、最も問題になるのは非同期処理です。

先述の**不要なProvider**は、AutoDisposeが有効で1つも`ref.watch`されていないProviderを指します。`ref.read`は`ref.watch`しているカウントにならないため、AutoDisposeが有効なProviderを`ref.read`で参照していると、そのProviderは**次の破棄タイミングで破棄**されます。

https://github.com/rrousselGit/riverpod/blob/riverpod-v3.2.0/packages/riverpod/lib/src/core/provider_container.dart#L904-L924

次のようなコードは、覚えがある方も多いのではないでしょうか？

```dart
@override
Widget build(BuildContext context, WidgetRef ref) {
  return FilledButton(
    onPressed: () async {
      await ref.read(authServiceProvider).signIn();
      if (!context.mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Success!!')),
      );
    },
    child: const Text('Sign in'),
  );
}
```

v3では`signIn`の非同期処理が完了する前に`authServiceProvider`が破棄されることで、処理が中断される可能性があります。また`authServiceProvider`の`onDispose`時に副作用がある場合、`authServiceProvider`が破棄されることで、意図しない動作につながるかもしれません。現状ではlinterが指摘してくれないため、`await`を頼りにコードをレビューし検討する必要があります。

本記事では、非同期処理と`ref`をどう組み合わせるとよいのか？ という問題を考えます。

## 解決策1. `ref.watch`

後述の**Widgetの生存期間よりも処理の時間が長いケース**ではない場合、最もシンプルなのは`ref.watch`でNotifierを保持する方法です。問題そのものの前提をひっくり返すことになりますが、Buttonの`onPressed`内で`ref.read`を使う必要がなくなります。

```dart
@override
Widget build(BuildContext context, WidgetRef ref) {
  final notifier = ref.watch(authServiceProvider.notifier);
  return FilledButton(
    onPressed: () async {
      await notifier.signIn();
      if (!context.mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Success!!')),
      );
    },
    child: const Text('Sign in'),
  );
}
```

最初は筆者も違和感があったのですが、「Widgetが破棄されたら非同期処理も終了するべきでは？」と考え、まあそれはそうか…となりました。v3に更新するにあたり、無心で一旦書き換えるのであれば、この方法がシンプルなWidgetも多いと思います。おそらく、従来の実装では「非同期で定義した関数(e.g. `signIn`)が完了するまで、`ref`が生存している」ことを前提にしているため、急場は凌げるでしょう。

この実装に置き換える場合、次のステップとして[Mutations](https://riverpod.dev/docs/concepts2/mutations)との組み合わせを検討できそうです。2026年2月初旬現在ではexperimentalな機能であるため、注意が必要ですが、「Widgetの生存期間と紐づく」非同期処理をよりユーザーフレンドリーに実装できる可能性があります。

## 解決策2. `keepAlive`

非同期処理の終了前に`ref`が破棄されることが問題であれば、破棄されないようにすれば良いはずです。すると、`keepAlive`が思い浮かびます。`keepAlive`はAutoDisposeが有効なProviderに対して、その破棄を防止するための仕組みです。

https://riverpod.dev/docs/concepts2/auto_dispose

https://zenn.dev/koji_1009/articles/735a08e08b5be9

とはいえ、`keepAlive`は濫用すると不要なメモリ消費につながったり、意図しない状態の保持につながります。そのため、「`keepAlive`はこのケースで使うべき」という明確な基準や、ガイドラインを用意することが重要です。

### StatelessなSingleton

筆者は最近、「StatelessなSingletonは`keepAlive`してもよいのでは？」と考えています。

前述の`ref.watch`による解決方法はシンプルですが、WidgetよりもLogicの生存期間が長くなるケースでは使いづらい場面もあります。典型的には、ログインやログアウトの処理、アナリティクスへの送信などです。これらの処理は、Logicの終了まで起点となるWidgetが存在しないケースがあります。^[厳密に言えば、rootのAppをwatchすれば解決できます。ただ、それは適切な設計なのか？ という疑問が残ります。]

この問題が難しいのは、非同期処理が絡むと「非同期処理の途中でWidgetが破棄される」可能性が生じ、確率的に発生するバグにつながることです。手元でさっと試すと問題が起きないが、実際のアプリで何度も何度も試すと問題が発生する、という事態が生じます。

このため、ある非同期処理を確実に完了させるために、`keepAlive`の利用を1つの選択肢として考えています。特に、次の条件を満たすProviderについては、`keepAlive`を利用してもよいと考えています。

* Statelessであること (状態を持たないこと)
* 冪等なFunctionを提供すること (同じ引数で呼び出した場合、常に同じ結果を返すこと)
* Singletonとして振る舞うこと (アプリ全体で1つだけのインスタンスであること)

これらの条件を満たすProviderは、状態を持たないためにメモリ消費が少なく、また状態の不整合が発生しません。さらに、Singletonとして振る舞うため、複数のWidgetから同じProviderを参照しても問題が生じにくくなります。

### 引数でFunctionを受け取るSingleton

最もクリーンな設計は、Singletonに対して「`ref`で実行するfunctionを引数で与える」方法です。例えば、次のようなコードになります。

```dart
@riverpod
AuthService authService(Ref ref) {
  ref.keepAlive();
  return AuthService(
    signInFunction: (String username, String password) async {
      await ref.read(authRepositoryProvider).signIn(username, password);
    },
    sendAnalyticsFunction: (String eventName) {
      ref.read(analyticsProvider).logEvent(eventName);
    },
  );
}

class AuthService {
  const AuthService({
    required this.signInFunction,
    required this.sendAnalyticsFunction,
  });

  final Future<void> Function(String username, String password) signInFunction;
  final void Function(String eventName) sendAnalyticsFunction;

  Future<void> signIn(String username, String password) async {
    await signInFunction(username, password);
    sendAnalytics('sign_in');
  }
}
```

この方法では、`AuthService`は状態を持たず、引数で与えられた関数を利用して非同期処理を実行します。また`ref`は`keepAlive`されているため、非同期処理が完了するまで破棄されることはありません。

この実装の良いところは、`AuthService`のテストが容易になる点です。引数で関数を受け取るため、モック関数を渡してテストを実行できます。逆ややこしいのは、`ref`へのアクセスパターンが増えたときに、`AuthService`のコンストラクタ引数が増加することです。ここでは`signIn`とまとめましたが、`signInWithEmail`や`signInWithGoogle`など、複数の認証方法がある場合は、徐々に辛さが出てくるかもしれません。

### 引数で`ref`を受け取るSingleton

もう1つの方法として、Singletonに対して`ref`自体を引数で与える方法があります。例えば、次のようなコードになります。

```dart
@riverpod
AuthService authService(Ref ref) {
  ref.keepAlive();
  return AuthService(
    ref: ref,
  );
}

class AuthService {
  const AuthService({
    required this.ref,
  });

  final Ref ref;

  Future<void> signIn(String username, String password) async {
    await ref.read(authRepositoryProvider).signIn(username, password);
    ref.read(analyticsProvider).logEvent('sign_in');
  }
}
```

この方法では、`AuthService`は`ref`を直接利用して非同期処理を実行します。これにより、引数の数が増えることなく、必要なProviderにアクセスできます。一方で、`Ref`を渡してしまうと、`AuthService`の内部で任意のProviderにアクセスできるようになり、依存関係が不明瞭になる可能性があります。^[Refで幾つかのProviderにアクセスする必要があるケースを前提にしています]

このため`Ref`を引数で渡す場合には、いくつかのルールとテストケースによる工夫が必要です。具体的には、次のようなルールが必要です。

* `AuthService`内では、`ref.read`のみを利用すること
  * `ref.watch`や`ref.listen`は利用しないこと
* `AuthService`に対してunit testを実装し、100%に近いカバレッジを維持すること
  * 内部で利用するProviderをoverrideして、期待通りの動作をすることを確認する

### おわりに

Riverpodはv3になり、よりFlutterのWidgetのライフサイクルに沿った設計になりました。最初は戸惑うことも多いと思いますが、よくよく考えてみると、Providerの生存期間と非同期処理の完了期間を一致させることは理にかなっていると思います。

本記事では、とは言え既存の設計方針だと問題が生じるぞ…というケースに対して、筆者が考えていることをまとめました。特にStatelessなクラスを作ることで、より堅牢な設計ができるのでは？ と考えています。例えば、v2で実装していた[shared_preferences](https://pub.dev/packages/shared_preferences)をラップするNotifierはFunctional ProviderとStalesslessなSingletonの組み合わせで実装し直すことができそうな気がしています。

```dart
// before
@riverpod
class UserSettingsNotifier extends _$UserSettingsNotifier {
  @riverpod
  UserSettings build() {
    final prefs = ref.watch(sharedPreferencesProvider);
    final darkMode = prefs.getBool('dark_mode') ?? false;
    return UserSettings(darkMode: darkMode);
  }

  Future<void> toggleDarkMode() async {
    final prefs = ref.read(sharedPreferencesProvider);
    final newDarkMode = !state.darkMode;
    await prefs.setBool('dark_mode', newDarkMode);
    state = UserSettings(darkMode: newDarkMode);
  }
}
```

```dart
// after
@riverpod
UserSettings userSettings(Ref ref) {
  final prefs = ref.watch(sharedPreferencesProvider);
  final darkMode = prefs.getBool('dark_mode') ?? false;
  return UserSettings(darkMode: darkMode);
}

@riverpod
UserSettingsService userSettingsService(Ref ref) {
  ref.keepAlive();
  return UserSettingsService(ref: ref);
}

class UserSettingsService {
  const UserSettingsService({
    required this.ref,
  });

  final Ref ref;

  Future<void> toggleDarkMode() async {
    final prefs = ref.read(sharedPreferencesProvider);
    final currentSettings = ref.read(userSettingsProvider);
    final newDarkMode = !currentSettings.darkMode;
    await prefs.setBool('dark_mode', newDarkMode);
    ref.invalidate(userSettingsProvider);
  }
}
```

FlutterやFlutterを取り巻くエコシステムは、2026年も引き続き進化し続けると思います。楽しんでいきましょう！
