---
title: "ボトムアップで考える状態の保持・保存"
emoji: "🍜"
type: "tech"
topics:
  - "state"
published: false
---

AndroidやiOS向けのアプリケーションを考えていると、情報や状態の持ち方に悩みます。
ここでは、主に全体的な設計やコードレビューの際に考えることとなる、情報や状態の持ち方を整理します。

## どのような保持・保存方法があるのか(WIP)

AndroidやiOSでは、file systemへの書き込みや、OSが提供するSQLiteが利用できます。またCやC++のライブラリを持ち込むことで、その他のDBなどを持ち込むこともできます。
メモリー(揮発性メモリ)とディスク(不揮発性メモリ)が利用できることは、AndroidやiOSアプリケーション開発において重要な要素です。

### メモリー

語弊があることを承知で言えば、普通に領域を確保すると、メモリー上で情報が保持することになります。
言い切ってしまうのは難しいのすが、ここではAndroidとiOS、Flutterのdebugモードとreleaseモードの違い。そして端末内にある複数のメモリーについて、一旦無視してしまいます。というのも、KotlinやSwift、Dartでコードを書いている際には、あまり気にしない項目なためです。
また、デスクトップ向けと違い、いわゆる主記憶装置をSwap領域として利用することも想定しません。AndroidやiOS的には、Swapが発生するような状況では、そもそもアプリケーションが立ち上がらない状況になっているためです。

---

メモリー上に置いた情報は、アプリケーションにおいては、その読み書きの時間を無視して実装をすることができます。このため、メモリー上に展開した情報を読み取るロジックが複雑でない場合、同期的な処理で実装することができます。だいたい`List`や`Map`、常識的なサイズのクラスであればこの範疇に入るでしょう。
他方、メモリー上でDBを構築した場合、例えば[AndroidのRoomをin memoryで構築する場合](https://developer.android.com/reference/androidx/room/Room#inMemoryDatabaseBuilder(android.content.Context,java.lang.Class))や[iOSのRealmをin memoryで構築する場合](https://www.mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/#open-an-in-memory-realm)には、非同期処理となることもあります。

コードがリークしていない場合、メモリー上のデータはアプリケーションの破棄時に失われます。このため、*アプリケーションを立ち上げ直した時に再取得できる*情報であったり、*アプリケーション内の特定の画面のみ*で利用したいデータは、メモリー上に展開できます。一方で、アプリケーションの状態によらずに保持されているべき情報は、メモリー上だけで保持するべきではありません。
また、利用できるメモリーの量に注意する必要があります。例えば超微細な画像を数十枚メモリー上で保持してしまうと、利用できる領域を食い潰してしまうでしょう。一般的にスマートフォンに搭載されているメモリーは、デスクトップPCのものと比べて少なくなります。Android向けの開発では、ユーザーが利用している端末が多種多様なため、思っているよりも少ないメモリーしか利用できない場合があります。

### ディスク

AndroidやiOSでは、file systemへのアクセスをすることができます。

https://developer.android.com/training/data-storage

https://developer.apple.com/documentation/foundation/filemanager

https://pub.dev/packages/path_provider#supported-platforms-and-paths

AndroidとiOSで差異はあるのですが、ざっくり整理すると、*アプリケーション用のファイルを保存する領域*と*アプリケーション用のキャッシュを保存する領域*が存在します。後者はキャッシュ用のため、任意のタイミングで再駆除されても良いものを置くこととなります。なおアプリケーション用のファイルは、OSが提供するバックアップ機能の対象になることがあります。どの箇所がどのように保存されるかについては、それぞれのOSのドキュメントをご確認ください。

https://developer.android.com/guide/topics/data/autobackup

https://developer.apple.com/documentation/foundation/optimizing_your_app_s_data_for_icloud_backup/

---

この領域には、さまざまなファイルを保存することができます。アプリケーションでpathを管理すればよいので、保存する形式は問われません。例えばjsonやxml、jpg、txtといったメジャーなものが利用されるでしょう。
つまり、実装さえしてしまえば、大抵の情報はスマートフォンの中に保存することができます。

### メモリー + ディスク

AndroidやiOSでは、メモリーとディスクを適切に組み合わせたライブラリが提供されています。

典型的な例としては、Androidの[SharedPreferences](https://developer.android.com/reference/android/content/SharedPreferences)です。これは、ディスク上にxmlでファイルを保存しつつ、アプリケーションの動作中は(基本的には)メモリー上に展開されたキャッシュへの読み書きを行います。
この動きについては[SharedPreferences.Editor.apply()](https://developer.android.com/reference/android/content/SharedPreferences.Editor#apply())に記述があるので、気になる方は確認してみてください。

また、高速な画像の表示のためにもよく利用されます。Androidでは[Picasso](https://github.com/square/picasso)や[Glide](https://github.com/bumptech/glide)、[Coil](https://github.com/coil-kt/coil)。iOSでは[SDWebImage](https://github.com/SDWebImage/SDWebImage)や[Kingfisher](https://github.com/onevcat/Kingfisher)、[Nuke](https://github.com/kean/Nuke)。そして、Flutterでは[cached_network_image](https://pub.dev/packages/cached_network_image)が典型例でしょう。
これらのライブラリは、サーバーから取得した画像をメモリー上にキャッシュし、必要になったタイミングで高速に展開します。もしも大量の画像を保持することになった場合には、優先度の低い画像をメモリー上から破棄し、必要になったタイミングでディスク上に保存したキャッシュファイルから再取得します。

---

[Cloud Firestore](https://firebase.google.com/docs/firestore)や[Realm Sync](https://www.xlsoft.com/jp/products/realm/realm_sync.html)などは、この仕組みを上手に利用しているサービスです。
これらのサービスは、クライアントから見た場合、DBへのアクセスをアプリケーション内部で生成したインスタンスの操作で賄うことができるようになります。サービス側がディスクやサーバーへのリクエストなどを行っているのですが、ライブラリの作り上、メモリー上の操作のように感じられる、というわけです。

## 情報の期間

アプリケーションの中では、いろいろな情報を扱います。
あまり*典型的なアプリケーション*というものを定義するのも難しいので、筆者が関わったことのあるいくつかのアプリケーションをベースに、5つほど挙げてみます。とは言え、考えていると落ちるものがたくさんあります。

* サービスを成立させるための情報
* ユーザーアカウントを成立させるための情報
* ユーザーのための画面を成立させるための情報
* ユーザーの操作を管理するための情報
* ユーザー操作の結果を表示するための情報

これらの情報は**期間**、つまり情報がいつ無くなっても良いものになるか、が異なります。例えばアプリケーション内で記事を配信している場合、その*サービスを成立させるための情報*は*サービスが記事機能を提供している間*存在することが期待されます。一方、記事にユーザーがコメントを投稿するためのテキスト入力エリアでは、*入力されている文字情報*は*ユーザーが文字入力を開始し、投稿するか取りやめるか決めるまでの間*存在することが期待されます。
それがどれぐらいの日数や時間なのかはサービスごとに異なりますが、概念的に、これらの**期間**について整理が必要です。

### サービスの期間

アプリケーションを*あるサービスを提供する仕組み*と考えると、アプリケーションはサービスを提供するためのツールと言えます。
ここでは、この**サービスを構築するための情報**を、**サービスの期間**と一致する情報と定義します。

サービスを提供し始めた時から、サービスをクローズするまでの間、サービスの期間は存在することになります。(厳密に考えると、リリース前の開発中の状態や、終了後のお知らせだけの状態もあります。)
AndroidやiOSのアプリケーションがバックエンド的な存在を持たない場合は、この期間は*ストアにアプリケーションをリリースしている間*とも一致します。ただ、ある程度以上の規模感のサービスであれば、バックエンド側で管理していることが多いと言えます。

上記のモバイルアプリケーションのみの場合を除けば、バックエンド側で永続化され、サービスの都合に合わせて保持される期間が調整されます。
調整と言えっても、後述するその他の期間から比べれば、十二分に長い間保持される情報です。このため、AndroidやiOSアプリケーションでは、この情報をサーバーから都度取得するか、一度取得してキャッシュするかすることになります。

### アプリケーションの期間

ここではAndroidやiOSのアプリケーションが立ち上がっている間、利用される情報のことを指します。ユーザーを特定するためのIDであったり、各種設定などのことを想定しています。
アプリケーションにサインインの機能がある場合には、サインインがされているかどうかなどを、アプリケーションの起動時から終了時までUIに反映する必要があります。アプリケーションを破棄した場合には、再度サインインをユーザーに求めるか、最後にサインインした際に利用した情報をディスク上に保存することで、メモリー上に復元します。
この期間は、サービス全体から見ると、ユーザーが*アカウントを作成した*時から始まり、*アカウントを削除した*時まで保持しなければならない情報です。このため、サービスの期間よりも、アプリケーションの期間は短い存在です。

難しいのは、このアプリケーションの期間は*アプリケーションの実行中にはメモリー上*で扱われるものですが、*アプリケーションが実行されていない時にはディスク上*で扱われるものであるという点です。
特にOSが提供するバックアップの仕組みにのっていたりすると、端末からアプリケーションを削除しても、再度インストールした際に参照することができるようになります。このため、コードを書く時に意識するのは**アプリケーションが起動してから終了するまで**なのですが、設計する際には**アプリケーションがインストールされてからアンインストールされるまで**を考えることとなります。

### 画面の期間

Androidにおける`Activity`、iOSにおける`UIViewController`の単位です。
なお近年では、タブレットやデスクトップ向けの開発も想定されるようになりつつあるため、1つの画面の中に複数の機能が入ることがあります。

画面の期間は、フレームワークによるところもありますが、おおよそ*画面が表示されてから、される前の画面に戻るまで*の間となります。一例を挙げると、Aという画面を開いたのち、Bの画面を重ねる形で開いた場合、Aの画面は(前面に表示されていなくとも)保持されています。Bの画面からAの画面に戻り、Aの画面からそれ以前の画面に戻った際、Aの画面は破棄されることとなります。
この考えは、画面ごとに機能がまとまっているケースで、実装を簡単なものにします。タイムラインを眺める画面であれば、画面を開いた時にタイムラインのリストを取得すれば、開いた時に最新のタイムラインを表示できます。もしもユーザーがタイムラインの更新をしたい場合には、画面の中に更新ボタンを追加し、タップされた際にリストの再取得をすれば良いこととなります。
一方で、ユーザーの体験からすると、問題が起きることがあります。タイムラインの例で言えば、タイムラインの画面を開いた時にリストの取得をするため、画面の開き直しのたびに取得待ちが発生することで、動作が遅い印象を与えることがあります。また、ある画面から別の画面に情報を渡す際に、OSが提供する画面と画面で通信する仕組みを使わなければなりません。大抵の場合、このOSが提供する仕組みは型安全ではなく、煩雑な処理を実装することとなります。

### ViewやWidgetの期間

画面を構成する要素の期間です。AndroidやiOSのアプリケーションにおいては、UIに依存しないバックグラウンドタスクを除くと、最も期間が短いものになります。
Widgetは、Androidにおける[RecycleView](https://developer.android.com/guide/topics/ui/layout/recyclerview)などのように**画面で表示されている間だけ**存在するものと、**表示される要素としてレイアウトされている間**存在するものがあります。この違いは大きいのですが、Widgetの呼び出し方の問題であるので、それぞれのWidgetでは呼び出されてから破棄されるまでの処理、ライフサイクルに合わせた実装が必要となります。

前述の画面単位で情報を管理する場合、それより小さい単位であるViewやWidgetは、画面から情報を引き渡されるだけの存在になります。一方で、例えば文字の入力やONとOFFを切り替えるスイッチなどでは、ViewやWidgetそれ自体が状態を保つことがあります。Flutterで言えば、`StatelessWidget`と`StatefulWidget`がある、と言えます。
ここでは、アプリケーションを構成する最小の*期間*として、ViewやWidgetそのものかViewやWidgetの生存している期間と一致する*ViewやWidgetの期間*を考えます。

## 状態の管理

俯瞰してみると、画面もViewやWidgetの一形態と見なすことができます。Flutterのように、アプリケーションに関わる大半のクラスが`Widget`であるフレームワークにおいては、アプリケーションとして振る舞う`Widget`とそれ以外の`Widget`ということもできます。このため、単純に継承元のクラスで分割しようとすると、なかなか話がまとまりません。
一方で、ViewやWidgetだけに状態を持たせようとすると、実装がごちゃごちゃになってしまいます。シンプルな記述で、堅牢な設計を行うために、さまざまな状態管理手法が存在します。

### より良い設計について

極端な例になりますが、アプリケーションの内部で扱う情報をすべてディスク上で管理する実装は可能です。この実装の場合、それぞれの処理のたびに書き込みが発生してしまいますが、ユーザーがアプリケーションを間違って閉じたとしても、最後に開いていた画面を復元することができます。とはいえ、この設計を採用した方が良いだろう、と考えられるケースは稀だと思います。
私見ですが、情報や状態は、その期間に合った方法で保持する必要があります。そうでなければ、設計や実装の議論において「より良いもの」を探すことが困難になってしまうためです。「より良い」状態管理を考えるひとつの補助線が、情報や状態の期間であり、保持される場所です。

AndroidとiOS、Flutterでは、メモリー上で状態を管理する手法に違いはなくなりつつあります。確かに、フレームワークがViewやWidgetごとの状態管理に関心をあまり持っていないiOS、ViewやWidgetではなく`Activity`や`Fragment`毎の管理を行っていたAndroidという側面はありました。しかし宣言的UIのタームに入ってからは、Swiftの[AsyncStream](https://developer.apple.com/documentation/swift/asyncstream)やKotlinの[Flow](https://developer.android.com/kotlin/flow)といったプログラミング言語の力を活用して、ViewやWidgetごとの管理ができる下地が整っています。またFlutterにおいては、[Provider](https://pub.dev/packages/provider)や[Riverpod](https://riverpod.dev/)を利用することで、コード量を抑えつつ実装ができる状態になっています。
ディスク上で情報を保存する手法については、AndroidがiOSやFlutterよりも環境が整っています。公式にリリースされている[Room](https://developer.android.com/training/data-storage/room)や[Paging](https://developer.android.com/topic/libraries/architecture/paging/v3-overview)、そしてOSSで開発されている[Store](https://github.com/MobileNativeFoundation/Store)のようなライブラリが整っており、メモリーとディスクの利点を掛け合わせた実装がしやすくなっています。iOSでは[Realm](https://realm.io/)、Flutterでは[Isar](https://isar.dev/)を利用することはできますが、統合のしやすさで言えば、Androidの環境の方が進んでいます。

とはいえ、一般的なアプリケーションの開発においては、3つの環境に違いはありません。よって、アプリケーションの特性や、実装者の好みによって保持の方法は変わっていきます。

---

以下、筆者の意見です。全体としては

https://zenn.dev/koji_1009/articles/f15ff24e20e36f

にてまとめた通り、MVVMが最適だったこともあれば、そうではなくなることもあると考えています。

筆者の意見としては、宣言的UIを利用できるフレームワークであれば、最小単位のViewやWidgetは**可能な限りどこからでも呼び出せる**設計が望ましいと感じています。この設計ができていれば、Widgetのテストは該当のWidgetだけを呼び出せば良くなります。また、仕様の変更でUIを変更する際には、修正範囲を最小限に保つことができるようになります。
ただ、これも従来のMVVMを否定するものではありません。従来のAndroidでは、ライフサイクルの基準となるのが`Activity`や`Fragment`であったために、AACの`ViewModel`が適していました。同様に、宣言的UIのAndroidやFlutterであれば、ライフサイクルの基準を個別のViewやWidgetに寄せた方が良いだろう、と考えています。もちろん、`Button`や`Text`ごとに状態の管理をする必要性はなさそうなので、再利用したくなるようなWidgetとしてまとめた上で、状態管理を行うのが良いと考えています。

### アプリケーションの特性との合致

アプリケーションがサービスを利用するためのものである以上、サービスの違いの数だけアプリケーションには違いがあります。
当然ではありますが、サービスの大きな違いがアプリケーションのあり方に違いを及ぼさないこともありますし、小さな差が大きな違いを生み出すこともあります。

以下では、筆者が特に意識している、3つのケースを紹介します。

#### サーバーとの通信回数を最小限にするケース

サーバーへのリクエストを抑えることで、通信データ量やバッテリーの消費量を抑えるケースです。
多くの場合、AndroidやiOSのアプリケーションはこのケースに該当すると思われます。

https://developer.android.com/topic/architecture/data-layer/offline-first

Androidのドキュメントにおいて、**オフラインファースト**と表現されているコンセプトも含まれます。日常生活の中でも、例えば奥まった場所にあるエレベーターの中でスマートフォンを開いた時や、初めて入ったカフェでWi-Fi機能のみのタブレットを開いた時などなど、端末がオフラインになることはあります。特にAndroid向けのアプリケーションを海外展開した場合には、利用できるインターネット回線が安定していない状況のユーザーがいるかもしれず、重要なコンセプトとなります。

---

このケースでは、HTTPのキャッシュを利用するものと、そうではなく開発者が独自にキャッシュを作成するものがあります。
HTTPのキャッシュでは、iOSにおいては、[URLSession](https://developer.apple.com/documentation/foundation/urlsession)が[ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag)を標準的に利用され、Androidでは[OkHttp](https://github.com/square/okhttp)の[cache](https://square.github.io/okhttp/features/caching/)が利用されることが多い印象です。オプションの設定によって振る舞いが変わる点も多いのですが、基本的には、[HTTP Cacahe](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching)の仕様を読んだ上で、プラットフォームごとの実装を確認することとなります。
Flutterの場合、標準的な[http](https://pub.dev/packages/http)にHTTP Cacheの仕組みが備わっていません。このため、[flutter_cache_manager](https://pub.dev/packages/flutter_cache_manager)を自前で追加するか、[dio](https://pub.dev/packages/dio)を[dio_http_cache](https://pub.dev/packages/dio_http_cache)と組み合わせて使うなどの一手間を加える必要があります。

開発者が独自にキャッシュを実装する場合、ディスク上に保存する仕組みを構築する必要があります。
もっとも典型的なものは、画像のキャッシュです。画像のリクエストにおいては、HTTP Cacheではなく、典型的にはURLをキーとした永続的なキャッシュを作成します。他には[Apollo](https://www.apollographql.com/)のキャッシュなども、独自の仕組みを利用しています。
これらの他に、GoogleMapのオフラインマップのような、オフラインでも機能が利用できるようにするキャッシュ。ゲームにおける、音楽などのリソースを事前にダウンロードする仕組みなどがあります。

キャッシュを利用して通信回数を最小限にしようとすると、細かなキャッシュの管理が必要になります。
このため、サーバーとディスクの間で情報を適切に管理する、Repository層を実装することになります。

https://developer.android.com/codelabs/basic-android-kotlin-training-repository-pattern

#### サーバーからのレスポンスがクライアントの状態と一致するケース

サーバーから得られるレスポンスが、クライアントにおける状態と一致する場合、サーバーからのレスポンスを中心に設計します。
このケースでは、クライアント側で状態をどのように管理することよりも、サーバーからのレスポンスをどれだけ適切に管理できるかが重要になります。つまり*いつまでキャッシュを利用して良いのか*そして、*キャッシュをどのタイミングで更新するべきか*に主眼が置かれます。

この実装はWebの開発において、議論が先行している印象です。例えば[react-query](https://github.com/TanStack/query)や[swr](https://github.com/vercel/swr)などです。サーバーからのレスポンスを簡単にキャッシュし、それを元にViewを構築する設計が議論されています。
GraphQLを利用する場合には、画面の構築に必要なプロパティをqueryとして表現することができるため、表示したい状態とレスポンスのキャッシュが一致しやすくなります。

---

レスポンスがWidgetの表示と一致するということは、Widgetの内部でサーバーへのリクエストを行っても問題がないことになります。となると、情報を*画面*ではなく*Widget*で保持するだけで良くなります。
このため、不必要に*あるWidgetが別のWidgetの子要素となる*ケースを避けることができ、レイアウトの自由度が高まります。タブレットやデスクトップ向けのレイアウトを作成する際、スマートフォン向けでは表示しないWidgetであっても、特に考慮する必要なくWidgetを追加できるようになるのは強みです。このため、ViewやWidgetに処理を閉じた方が、実装がしやすくなります。

一方で、どのViewをどのようにレイアウトするかまで、レスポンスでコントロールできるようになります。このため、レスポンスを取得するWidgetが、そのWidgetの子要素をレスポンスに応じて組み替えることも可能です。
突き詰めていくとレイアウトにクライアントとサーバーのどちらが責任を持つのか、という議論ができるようになります。サーバーサイドからHTMLを配布するのではなく、JSONを配布することでアプリケーションのUIを構築する仕組みを取り入れることができる、ということです。

#### 多くの処理がクライアント側で行われるケース

カメラによる写真や動画の撮影、録音などの端末上で処理がある程度完結する場合、通信処理はあまり重要な処理になりません。
このようなアプリケーションでは、アプリケーションの目的を達成するために、サービスに応じた設計をすることとなります。

Android端末に搭載されている時計アプリのコードを見ると、一般的に議論されるような設計になっていません。しかし、これは時計アプリが複雑であるためであり、必要に応じた実装になっているように感じます。

https://cs.android.com/android/platform/superproject/+/master:packages/apps/DeskClock/src/com/android/deskclock/

## 終わりに

AndroidやiOS向けのアプリケーションを開発する際、面白いのは、どれだけfile systemを適切に利用できるかだと思っています。
