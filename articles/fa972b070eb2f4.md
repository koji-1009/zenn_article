---
title: "RiverpodのautoDispose深掘り"
emoji: "👀"
type: "tech"
topics: 
  - flutter
  - riverpod
published: false
---

Riverpod、便利ですよね。毎日使っています。
そんなRiverpodには、`.autoDispose`という便利な機能があります。

https://docs-v2.riverpod.dev/docs/concepts/modifiers/auto_dispose

この`.autoDispose`は、効率的なアプリケーション開発を助けてくれます。
この仕組みについて、コードから理解を深めてみよう、というのが記事の趣旨です。

---

なお、この文章は**riverpod: 2.3.1**を参照しています。

https://github.com/rrousselGit/riverpod/tree/riverpod-v2.3.1

## Riverpodと`ProviderContainer`

手始めに、Riverpodにおける`ProviderContainer`の**破棄タイミング**について確認しましょう。なお、ここではFlutterにRiverpodを利用したケースを紹介します。
確認するべきクラスは次のとおりです。

| クラス | パッケージ | 継承 |
| :---: | :---: | :---: |
| [ProviderScope](https://github.com/rrousselGit/riverpod/blob/riverpod-v2.3.1/packages/flutter_riverpod/lib/src/framework.dart#L80) | [flutter_riverpod](https://pub.dev/packages/flutter_riverpod) | `extends StatefulWidget` |
| [ProviderScopeState](https://github.com/rrousselGit/riverpod/blob/riverpod-v2.3.1/packages/flutter_riverpod/lib/src/framework.dart#L158) | [flutter_riverpod](https://pub.dev/packages/flutter_riverpod) | `extends State<ProviderScope>` |
| [ProviderContainer](https://github.com/rrousselGit/riverpod/blob/riverpod-v2.3.1/packages/riverpod/lib/src/framework/container.dart#L100) | [riverpod](https://pub.dev/packages/riverpod) | `implements Node` |

### `ProviderScope`

RiverpodをFlutterのアプリケーションに導入するには、`ProviderScope`を利用します。大抵の場合は、サンプルコードにあるように、`runApp`の中で呼び出す形になるでしょう。

https://docs-v2.riverpod.dev/docs/getting_started

```dart
void main() {
  runApp(
    ProviderScope(
      child: MyApp(),
    ),
  );
}
```

`ProviderScope`は`StatefulWidget`を継承しているため、これは`MyApp`の親に1つ`StatefulWidget`を置いています。`runApp`の直下は、アプリケーションのrootとなるWidgetです。このため、起動から破棄までを管理できることになります。

`ProviderScope`は`StatefulWidget`なため、固有の`State`を持っています。それが`ProviderScopeState`です。そして、この`ProviderScopeState`のプロパティとして、`ProviderContainer`を保持しています。
下にコードを抜粋していますが、お時間があれば、ぜひ一度ソースコードを眺めてみてください。

```dart
class ProviderScopeState extends State<ProviderScope> {
  @visibleForTesting
  late final ProviderContainer container;

  @override
  void initState() {
    super.initState();

    final parent = _getParent();
    container = ProviderContainer(
      parent: parent,
      overrides: widget.overrides,
      observers: widget.observers,
    );
  }

  @override
  Widget build(BuildContext context) {
    return UncontrolledProviderScope(
      container: container,
      child: widget.child,
    );
  }

  @override
  void dispose() {
    container.dispose();
    super.dispose();
  }
}
```

ここで登場する`UncontrolledProviderScope`は`InheritedWidget`を継承したクラスで、この要素に対して`ProviderContainer`を提供する役割を持っています。実装を確認すると細々とした調整を行っているようなのですが、今回はスキップします。
`ProviderScope`により、アプリケーションの起動時に用意され破棄時に`dispose`される`ProviderContainer`が提供されることがわかりました。では、この`ProviderContainer`をどのようにWidgetが呼び出しているのかを、先に確認します。

## Riverpodと`ConsumerStatefulWidget`

RiverpodをFlutterで利用するためには、`Consumer`・`ConsumerWidget`・`ConsumerStatefulWidget`のいずれかを利用します。

| クラス | パッケージ | 継承 |
| :---: | :---: | :---: |
| [ConsumerWidget](https://github.com/rrousselGit/riverpod/blob/riverpod-v2.3.1/packages/flutter_riverpod/lib/src/consumer.dart#L422) | [flutter_riverpod](https://pub.dev/packages/flutter_riverpod) | `extends ConsumerStatefulWidget` |
| [ConsumerStatefulWidget](https://github.com/rrousselGit/riverpod/blob/riverpod-v2.3.1/packages/flutter_riverpod/lib/src/consumer.dart#L482) | [flutter_riverpod](https://pub.dev/packages/flutter_riverpod) | `extends StatefulWidget` |
| [ConsumerStatefulElement](https://github.com/rrousselGit/riverpod/blob/riverpod-v2.3.1/packages/flutter_riverpod/lib/src/consumer.dart#L505) | [flutter_riverpod](https://pub.dev/packages/flutter_riverpod) | `extends StatefulElement implements WidgetRef` |
| [ProviderContainer](https://github.com/rrousselGit/riverpod/blob/riverpod-v2.3.1/packages/riverpod/lib/src/framework/container.dart#L100) | [riverpod](https://pub.dev/packages/riverpod) | `implements Node` |

### `ConsumerWidget`

`Consumer`は`ConsumerWidget`を継承し、builderによる子要素の生成を提供するクラスです。コードを確認すると簡単にわかるのですが、`Consumer`と`ConsumerWidget`の間にはほとんど差がありません。`StatefulWidgegt`の内部でProviderを参照したいケースや、`child`プロパティを利用したパフォーマンスの最適化を行う場合、`ConsumerWidget`ではなく`Consumer`を使うべきとされています。
`ConsumerWidget`は`ConsumerStatefulWidget`を継承したクラスです。実態としては`StatefulWidget`の継承クラスになりますが、API的に`StatelessWidget`のように利用できるよう、調整されています。

APIの関係性を把握するため、必要な箇所だけ抜粋すると、次のような処理になっています。

```dart
abstract class ConsumerWidget extends ConsumerStatefulWidget {
  const ConsumerWidget({super.key});

  Widget build(BuildContext context, WidgetRef ref);

  @override
  _ConsumerState createState() => _ConsumerState();
}

class _ConsumerState extends ConsumerState<ConsumerWidget> {
  @override
  WidgetRef get ref => context as WidgetRef;

  @override
  Widget build(BuildContext context) {
    return widget.build(context, ref);
  }
}

abstract class ConsumerState<T extends ConsumerStatefulWidget> extends State<T> {
  late final WidgetRef ref = context as WidgetRef;
}
```

サッと見てわかる通り、重要な実装は全て`ConsumerStatefulWidget`にまとまっています。

### `ConsumerStatefulWidget`

`ConsumerStatefulWidget`は`StatefulWidget`を継承したクラスです。`State`として`ConsumerState`を、そして`StatefulElement`として`ConsumerStatefulElement`を返します。
このうち、Riverpod的に重要なのは`ConsumerStatefulElement`です。

下にコードを記載します。
処理に影響がない範囲でコードの省略や修正をしていますので、ぜひお時間のある時に元のコードをご確認ください。

```dart
class ConsumerStatefulElement extends StatefulElement implements WidgetRef {
  ConsumerStatefulElement(ConsumerStatefulWidget super.widget);

  late ProviderContainer _container = ProviderScope.containerOf(this);
  var _dependencies = <ProviderListenable<Object?>, ProviderSubscription<Object?>>{};
  Map<ProviderListenable<Object?>, ProviderSubscription<Object?>>? _oldDependencies;

  @override
  Widget build() {
    try {
      _oldDependencies = _dependencies;
      _dependencies = {};
      return super.build();
    } finally {
      for (final dep in _oldDependencies!.values) {
        dep.close();
      }
      _oldDependencies = null;
    }
  }

  @override
  void unmount() {
    super.unmount();

    for (final dependency in _dependencies.values) {
      dependency.close();
    }
  }

  @override
  T watch<T>(ProviderListenable<T> target) {
    return _dependencies.putIfAbsent(target, () {
      final oldDependency = _oldDependencies?.remove(target);

      if (oldDependency != null) {
        return oldDependency;
      }

      return _container.listen<T>(
        target,
        (_, __) => markNeedsBuild(),
      );
    }).read() as T;
  }

  @override
  T read<T>(ProviderListenable<T> provider) {
    return ProviderScope.containerOf(this, listen: false).read(provider);
  }

  @override
  State refresh<State>(Refreshable<State> provider) {
    return ProviderScope.containerOf(this, listen: false).refresh(provider);
  }

  @override
  void invalidate(ProviderOrFamily provider) {
    _container.invalidate(provider);
  }

  @override
  BuildContext get context => this;
}
```

`ProviderScope.containerOf`が頻繁に呼び出されているのがわかりますね。これはcontextから参照できる`InhertedWidget`を参照し、`ProviderContainer`を取得する関数です。先ほど確認した通り、大抵の場合はアプリケーションのrootに`ProviderScope`を置いているため、アプリケーション全体で利用できる`ProviderContainer`を参照することになります。
`StatefulElement`を継承しているクラスでは、`_dependencies`(`ref.watch`を呼び出したもの)と`_listeners`(`ref.listen`を呼び出したもの)の更新をしています。

Riverpodの動きを把握するためには、`watch`と`build`、そして`unmount`を確認すれば大丈夫です。

```dart
@override
Widget build() {
  try {
    _oldDependencies = _dependencies;
    _dependencies = {};
    return super.build();
  } finally {
    for (final dep in _oldDependencies!.values) {
      dep.close();
    }
    _oldDependencies = null;
  }
}

@override
void unmount() {
  /// Calling `super.unmount()` will call `dispose` on the state
  /// And [ListenManual] subscriptions should be closed after `dispose`
  super.unmount();

  for (final dependency in _dependencies.values) {
    dependency.close();
  }
}

@override
T watch<T>(ProviderListenable<T> target) {
  return _dependencies.putIfAbsent(target, () {
    final oldDependency = _oldDependencies?.remove(target);

    if (oldDependency != null) {
      return oldDependency;
    }

    return _container.listen<T>(
      target,
      (_, __) => markNeedsBuild(),
    );
  }).read() as T;
}
```

`build`の処理は一見わかりにくいのですが、`ConsumerStatefulWidget`を継承したクラスで`super.build`を呼び出すことはほぼないため、実行されることは稀です。`unmount`は[Elementのライフサイクル](https://api.flutter.dev/flutter/widgets/Element-class.html)に詳細があるのですが、非アクティブになってから所定の時間後に遷移する状態です。一度`unmount`になった`Element`は、再度`Element`のtreeに追加されることがないため、破棄されることが決定ずれられたタイミングであると言えます。

### `ProviderContainer`の`dispose`

ここまでにみてきた処理は、基本的な呼び出しと破棄の処理desu
。

Providerは`ProviderScope`内の`ProviderContainer`に紐づいています。最も基本的な`ConsumerStatefulWidget`のコードを見ると、`read`と`watch`ともに`ProviderScope.containerOf`を利用した取得であることが確認できます。
また`ConsumerStatefulWidget`の`unmount`時、`ref.watch`で参照した`ProviderSubscription`が`close`されます。これは`ProviderContainer`の`listen`関数の呼び出しであり、stateの変更時に呼び出されるコールバックです。

https://pub.dev/documentation/riverpod/2.3.1/riverpod/ProviderContainer/listen.html
