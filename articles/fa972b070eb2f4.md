---
title: "Riverpodã®autoDisposeæ·±æ˜ã‚Š"
emoji: "ğŸ‘€"
type: "tech"
topics: 
  - flutter
  - riverpod
published: false
---

Riverpodã€ä¾¿åˆ©ã§ã™ã‚ˆã­ã€‚æ¯æ—¥ä½¿ã£ã¦ã„ã¾ã™ã€‚
ãã‚“ãªRiverpodã«ã¯ã€`.autoDispose`ã¨ã„ã†ä¾¿åˆ©ãªæ©Ÿèƒ½ãŒã‚ã‚Šã¾ã™ã€‚

https://docs-v2.riverpod.dev/docs/concepts/modifiers/auto_dispose

ã“ã®`.autoDispose`ã¯ã€åŠ¹ç‡çš„ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹ç™ºã‚’åŠ©ã‘ã¦ãã‚Œã¾ã™ã€‚
ã“ã®ä»•çµ„ã¿ã«ã¤ã„ã¦ã€ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ç†è§£ã‚’æ·±ã‚ã¦ã¿ã‚ˆã†ã€ã¨ã„ã†ã®ãŒè¨˜äº‹ã®è¶£æ—¨ã§ã™ã€‚

---

ãªãŠã€ã“ã®æ–‡ç« ã¯**riverpod: 2.3.1**ã‚’å‚ç…§ã—ã¦ã„ã¾ã™ã€‚

https://github.com/rrousselGit/riverpod/tree/riverpod-v2.3.1

## Riverpodã¨`ProviderContainer`

æ‰‹å§‹ã‚ã«ã€Riverpodã«ãŠã‘ã‚‹`ProviderContainer`ã®**ç ´æ£„ã‚¿ã‚¤ãƒŸãƒ³ã‚°**ã«ã¤ã„ã¦ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚ãªãŠã€ã“ã“ã§ã¯Flutterã«Riverpodã‚’åˆ©ç”¨ã—ãŸã‚±ãƒ¼ã‚¹ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚
ç¢ºèªã™ã‚‹ã¹ãã‚¯ãƒ©ã‚¹ã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™ã€‚

| ã‚¯ãƒ©ã‚¹ | ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ | ç¶™æ‰¿ |
| :---: | :---: | :---: |
| [ProviderScope](https://github.com/rrousselGit/riverpod/blob/riverpod-v2.3.1/packages/flutter_riverpod/lib/src/framework.dart#L80) | [flutter_riverpod](https://pub.dev/packages/flutter_riverpod) | `extends StatefulWidget` |
| [ProviderScopeState](https://github.com/rrousselGit/riverpod/blob/riverpod-v2.3.1/packages/flutter_riverpod/lib/src/framework.dart#L158) | [flutter_riverpod](https://pub.dev/packages/flutter_riverpod) | `extends State<ProviderScope>` |
| [ProviderContainer](https://github.com/rrousselGit/riverpod/blob/riverpod-v2.3.1/packages/riverpod/lib/src/framework/container.dart#L100) | [riverpod](https://pub.dev/packages/riverpod) | `implements Node` |

### `ProviderScope`

Riverpodã‚’Flutterã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«å°å…¥ã™ã‚‹ã«ã¯ã€`ProviderScope`ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚å¤§æŠµã®å ´åˆã¯ã€ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã«ã‚ã‚‹ã‚ˆã†ã«ã€`runApp`ã®ä¸­ã§å‘¼ã³å‡ºã™å½¢ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚

https://docs-v2.riverpod.dev/docs/getting_started

```dart
void main() {
  runApp(
    ProviderScope(
      child: MyApp(),
    ),
  );
}
```

`ProviderScope`ã¯`StatefulWidget`ã‚’ç¶™æ‰¿ã—ã¦ã„ã‚‹ãŸã‚ã€ã“ã‚Œã¯`MyApp`ã®è¦ªã«1ã¤`StatefulWidget`ã‚’ç½®ã„ã¦ã„ã¾ã™ã€‚`runApp`ã®ç›´ä¸‹ã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®rootã¨ãªã‚‹Widgetã§ã™ã€‚ã“ã®ãŸã‚ã€èµ·å‹•ã‹ã‚‰ç ´æ£„ã¾ã§ã‚’ç®¡ç†ã§ãã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚

`ProviderScope`ã¯`StatefulWidget`ãªãŸã‚ã€å›ºæœ‰ã®`State`ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ãã‚ŒãŒ`ProviderScopeState`ã§ã™ã€‚ãã—ã¦ã€ã“ã®`ProviderScopeState`ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¨ã—ã¦ã€`ProviderContainer`ã‚’ä¿æŒã—ã¦ã„ã¾ã™ã€‚
ä¸‹ã«ã‚³ãƒ¼ãƒ‰ã‚’æŠœç²‹ã—ã¦ã„ã¾ã™ãŒã€ãŠæ™‚é–“ãŒã‚ã‚Œã°ã€ãœã²ä¸€åº¦ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’çœºã‚ã¦ã¿ã¦ãã ã•ã„ã€‚

```dart
class ProviderScopeState extends State<ProviderScope> {
  @visibleForTesting
  late final ProviderContainer container;

  @override
  void initState() {
    super.initState();

    final parent = _getParent();
    container = ProviderContainer(
      parent: parent,
      overrides: widget.overrides,
      observers: widget.observers,
    );
  }

  @override
  Widget build(BuildContext context) {
    return UncontrolledProviderScope(
      container: container,
      child: widget.child,
    );
  }

  @override
  void dispose() {
    container.dispose();
    super.dispose();
  }
}
```

ã“ã“ã§ç™»å ´ã™ã‚‹`UncontrolledProviderScope`ã¯`InheritedWidget`ã‚’ç¶™æ‰¿ã—ãŸã‚¯ãƒ©ã‚¹ã§ã€ã“ã®è¦ç´ ã«å¯¾ã—ã¦`ProviderContainer`ã‚’æä¾›ã™ã‚‹å½¹å‰²ã‚’æŒã£ã¦ã„ã¾ã™ã€‚å®Ÿè£…ã‚’ç¢ºèªã™ã‚‹ã¨ç´°ã€…ã¨ã—ãŸèª¿æ•´ã‚’è¡Œã£ã¦ã„ã‚‹ã‚ˆã†ãªã®ã§ã™ãŒã€ä»Šå›ã¯ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚
`ProviderScope`ã«ã‚ˆã‚Šã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®èµ·å‹•æ™‚ã«ç”¨æ„ã•ã‚Œç ´æ£„æ™‚ã«`dispose`ã•ã‚Œã‚‹`ProviderContainer`ãŒæä¾›ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã—ãŸã€‚ã§ã¯ã€ã“ã®`ProviderContainer`ã‚’ã©ã®ã‚ˆã†ã«WidgetãŒå‘¼ã³å‡ºã—ã¦ã„ã‚‹ã®ã‹ã‚’ã€å…ˆã«ç¢ºèªã—ã¾ã™ã€‚

## Riverpodã¨`ConsumerStatefulWidget`

Riverpodã‚’Flutterã§åˆ©ç”¨ã™ã‚‹ãŸã‚ã«ã¯ã€`Consumer`ãƒ»`ConsumerWidget`ãƒ»`ConsumerStatefulWidget`ã®ã„ãšã‚Œã‹ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚

| ã‚¯ãƒ©ã‚¹ | ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ | ç¶™æ‰¿ |
| :---: | :---: | :---: |
| [ConsumerWidget](https://github.com/rrousselGit/riverpod/blob/riverpod-v2.3.1/packages/flutter_riverpod/lib/src/consumer.dart#L422) | [flutter_riverpod](https://pub.dev/packages/flutter_riverpod) | `extends ConsumerStatefulWidget` |
| [ConsumerStatefulWidget](https://github.com/rrousselGit/riverpod/blob/riverpod-v2.3.1/packages/flutter_riverpod/lib/src/consumer.dart#L482) | [flutter_riverpod](https://pub.dev/packages/flutter_riverpod) | `extends StatefulWidget` |
| [ConsumerStatefulElement](https://github.com/rrousselGit/riverpod/blob/riverpod-v2.3.1/packages/flutter_riverpod/lib/src/consumer.dart#L505) | [flutter_riverpod](https://pub.dev/packages/flutter_riverpod) | `extends StatefulElement implements WidgetRef` |
| [ProviderContainer](https://github.com/rrousselGit/riverpod/blob/riverpod-v2.3.1/packages/riverpod/lib/src/framework/container.dart#L100) | [riverpod](https://pub.dev/packages/riverpod) | `implements Node` |

### `ConsumerWidget`

`Consumer`ã¯`ConsumerWidget`ã‚’ç¶™æ‰¿ã—ã€builderã«ã‚ˆã‚‹å­è¦ç´ ã®ç”Ÿæˆã‚’æä¾›ã™ã‚‹ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ã‚³ãƒ¼ãƒ‰ã‚’ç¢ºèªã™ã‚‹ã¨ç°¡å˜ã«ã‚ã‹ã‚‹ã®ã§ã™ãŒã€`Consumer`ã¨`ConsumerWidget`ã®é–“ã«ã¯ã»ã¨ã‚“ã©å·®ãŒã‚ã‚Šã¾ã›ã‚“ã€‚`StatefulWidgegt`ã®å†…éƒ¨ã§Providerã‚’å‚ç…§ã—ãŸã„ã‚±ãƒ¼ã‚¹ã‚„ã€`child`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’åˆ©ç”¨ã—ãŸãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®æœ€é©åŒ–ã‚’è¡Œã†å ´åˆã€`ConsumerWidget`ã§ã¯ãªã`Consumer`ã‚’ä½¿ã†ã¹ãã¨ã•ã‚Œã¦ã„ã¾ã™ã€‚
`ConsumerWidget`ã¯`ConsumerStatefulWidget`ã‚’ç¶™æ‰¿ã—ãŸã‚¯ãƒ©ã‚¹ã§ã™ã€‚å®Ÿæ…‹ã¨ã—ã¦ã¯`StatefulWidget`ã®ç¶™æ‰¿ã‚¯ãƒ©ã‚¹ã«ãªã‚Šã¾ã™ãŒã€APIçš„ã«`StatelessWidget`ã®ã‚ˆã†ã«åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã€èª¿æ•´ã•ã‚Œã¦ã„ã¾ã™ã€‚

APIã®é–¢ä¿‚æ€§ã‚’æŠŠæ¡ã™ã‚‹ãŸã‚ã€å¿…è¦ãªç®‡æ‰€ã ã‘æŠœç²‹ã™ã‚‹ã¨ã€æ¬¡ã®ã‚ˆã†ãªå‡¦ç†ã«ãªã£ã¦ã„ã¾ã™ã€‚

```dart
abstract class ConsumerWidget extends ConsumerStatefulWidget {
  const ConsumerWidget({super.key});

  Widget build(BuildContext context, WidgetRef ref);

  @override
  _ConsumerState createState() => _ConsumerState();
}

class _ConsumerState extends ConsumerState<ConsumerWidget> {
  @override
  WidgetRef get ref => context as WidgetRef;

  @override
  Widget build(BuildContext context) {
    return widget.build(context, ref);
  }
}

abstract class ConsumerState<T extends ConsumerStatefulWidget> extends State<T> {
  late final WidgetRef ref = context as WidgetRef;
}
```

ã‚µãƒƒã¨è¦‹ã¦ã‚ã‹ã‚‹é€šã‚Šã€é‡è¦ãªå®Ÿè£…ã¯å…¨ã¦`ConsumerStatefulWidget`ã«ã¾ã¨ã¾ã£ã¦ã„ã¾ã™ã€‚

### `ConsumerStatefulWidget`

`ConsumerStatefulWidget`ã¯`StatefulWidget`ã‚’ç¶™æ‰¿ã—ãŸã‚¯ãƒ©ã‚¹ã§ã™ã€‚`State`ã¨ã—ã¦`ConsumerState`ã‚’ã€ãã—ã¦`StatefulElement`ã¨ã—ã¦`ConsumerStatefulElement`ã‚’è¿”ã—ã¾ã™ã€‚
ã“ã®ã†ã¡ã€Riverpodçš„ã«é‡è¦ãªã®ã¯`ConsumerStatefulElement`ã§ã™ã€‚

ä¸‹ã«ã‚³ãƒ¼ãƒ‰ã‚’è¨˜è¼‰ã—ã¾ã™ã€‚
å‡¦ç†ã«å½±éŸ¿ãŒãªã„ç¯„å›²ã§ã‚³ãƒ¼ãƒ‰ã®çœç•¥ã‚„ä¿®æ­£ã‚’ã—ã¦ã„ã¾ã™ã®ã§ã€ãœã²ãŠæ™‚é–“ã®ã‚ã‚‹æ™‚ã«å…ƒã®ã‚³ãƒ¼ãƒ‰ã‚’ã”ç¢ºèªãã ã•ã„ã€‚

```dart
class ConsumerStatefulElement extends StatefulElement implements WidgetRef {
  ConsumerStatefulElement(ConsumerStatefulWidget super.widget);

  late ProviderContainer _container = ProviderScope.containerOf(this);
  var _dependencies = <ProviderListenable<Object?>, ProviderSubscription<Object?>>{};
  Map<ProviderListenable<Object?>, ProviderSubscription<Object?>>? _oldDependencies;

  @override
  Widget build() {
    try {
      _oldDependencies = _dependencies;
      _dependencies = {};
      return super.build();
    } finally {
      for (final dep in _oldDependencies!.values) {
        dep.close();
      }
      _oldDependencies = null;
    }
  }

  @override
  void unmount() {
    super.unmount();

    for (final dependency in _dependencies.values) {
      dependency.close();
    }
  }

  @override
  T watch<T>(ProviderListenable<T> target) {
    return _dependencies.putIfAbsent(target, () {
      final oldDependency = _oldDependencies?.remove(target);

      if (oldDependency != null) {
        return oldDependency;
      }

      return _container.listen<T>(
        target,
        (_, __) => markNeedsBuild(),
      );
    }).read() as T;
  }

  @override
  T read<T>(ProviderListenable<T> provider) {
    return ProviderScope.containerOf(this, listen: false).read(provider);
  }

  @override
  State refresh<State>(Refreshable<State> provider) {
    return ProviderScope.containerOf(this, listen: false).refresh(provider);
  }

  @override
  void invalidate(ProviderOrFamily provider) {
    _container.invalidate(provider);
  }

  @override
  BuildContext get context => this;
}
```

`ProviderScope.containerOf`ãŒé »ç¹ã«å‘¼ã³å‡ºã•ã‚Œã¦ã„ã‚‹ã®ãŒã‚ã‹ã‚Šã¾ã™ã­ã€‚ã“ã‚Œã¯contextã‹ã‚‰å‚ç…§ã§ãã‚‹`InhertedWidget`ã‚’å‚ç…§ã—ã€`ProviderContainer`ã‚’å–å¾—ã™ã‚‹é–¢æ•°ã§ã™ã€‚å…ˆã»ã©ç¢ºèªã—ãŸé€šã‚Šã€å¤§æŠµã®å ´åˆã¯ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®rootã«`ProviderScope`ã‚’ç½®ã„ã¦ã„ã‚‹ãŸã‚ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å…¨ä½“ã§åˆ©ç”¨ã§ãã‚‹`ProviderContainer`ã‚’å‚ç…§ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚
`StatefulElement`ã‚’ç¶™æ‰¿ã—ã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã§ã¯ã€`_dependencies`(`ref.watch`ã‚’å‘¼ã³å‡ºã—ãŸã‚‚ã®)ã¨`_listeners`(`ref.listen`ã‚’å‘¼ã³å‡ºã—ãŸã‚‚ã®)ã®æ›´æ–°ã‚’ã—ã¦ã„ã¾ã™ã€‚

Riverpodã®å‹•ãã‚’æŠŠæ¡ã™ã‚‹ãŸã‚ã«ã¯ã€`watch`ã¨`build`ã€ãã—ã¦`unmount`ã‚’ç¢ºèªã™ã‚Œã°å¤§ä¸ˆå¤«ã§ã™ã€‚

```dart
@override
Widget build() {
  try {
    _oldDependencies = _dependencies;
    _dependencies = {};
    return super.build();
  } finally {
    for (final dep in _oldDependencies!.values) {
      dep.close();
    }
    _oldDependencies = null;
  }
}

@override
void unmount() {
  /// Calling `super.unmount()` will call `dispose` on the state
  /// And [ListenManual] subscriptions should be closed after `dispose`
  super.unmount();

  for (final dependency in _dependencies.values) {
    dependency.close();
  }
}

@override
T watch<T>(ProviderListenable<T> target) {
  return _dependencies.putIfAbsent(target, () {
    final oldDependency = _oldDependencies?.remove(target);

    if (oldDependency != null) {
      return oldDependency;
    }

    return _container.listen<T>(
      target,
      (_, __) => markNeedsBuild(),
    );
  }).read() as T;
}
```

`build`ã®å‡¦ç†ã¯ä¸€è¦‹ã‚ã‹ã‚Šã«ãã„ã®ã§ã™ãŒã€`ConsumerStatefulWidget`ã‚’ç¶™æ‰¿ã—ãŸã‚¯ãƒ©ã‚¹ã§`super.build`ã‚’å‘¼ã³å‡ºã™ã“ã¨ã¯ã»ã¼ãªã„ãŸã‚ã€å®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ã¯ç¨€ã§ã™ã€‚`unmount`ã¯[Elementã®ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«](https://api.flutter.dev/flutter/widgets/Element-class.html)ã«è©³ç´°ãŒã‚ã‚‹ã®ã§ã™ãŒã€éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ãªã£ã¦ã‹ã‚‰æ‰€å®šã®æ™‚é–“å¾Œã«é·ç§»ã™ã‚‹çŠ¶æ…‹ã§ã™ã€‚ä¸€åº¦`unmount`ã«ãªã£ãŸ`Element`ã¯ã€å†åº¦`Element`ã®treeã«è¿½åŠ ã•ã‚Œã‚‹ã“ã¨ãŒãªã„ãŸã‚ã€ç ´æ£„ã•ã‚Œã‚‹ã“ã¨ãŒæ±ºå®šãšã‚Œã‚‰ã‚ŒãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã‚ã‚‹ã¨è¨€ãˆã¾ã™ã€‚

### `ProviderContainer`ã®`dispose`

ã“ã“ã¾ã§ã«ã¿ã¦ããŸå‡¦ç†ã¯ã€åŸºæœ¬çš„ãªå‘¼ã³å‡ºã—ã¨ç ´æ£„ã®å‡¦ç†desu
ã€‚

Providerã¯`ProviderScope`å†…ã®`ProviderContainer`ã«ç´ã¥ã„ã¦ã„ã¾ã™ã€‚æœ€ã‚‚åŸºæœ¬çš„ãª`ConsumerStatefulWidget`ã®ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ã‚‹ã¨ã€`read`ã¨`watch`ã¨ã‚‚ã«`ProviderScope.containerOf`ã‚’åˆ©ç”¨ã—ãŸå–å¾—ã§ã‚ã‚‹ã“ã¨ãŒç¢ºèªã§ãã¾ã™ã€‚
ã¾ãŸ`ConsumerStatefulWidget`ã®`unmount`æ™‚ã€`ref.watch`ã§å‚ç…§ã—ãŸ`ProviderSubscription`ãŒ`close`ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯`ProviderContainer`ã®`listen`é–¢æ•°ã®å‘¼ã³å‡ºã—ã§ã‚ã‚Šã€stateã®å¤‰æ›´æ™‚ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã§ã™ã€‚

https://pub.dev/documentation/riverpod/2.3.1/riverpod/ProviderContainer/listen.html

## Riverpodã¨Provider

ã“ã“ã‹ã‚‰ã¯ã€Providerã«ã¤ã„ã¦ç¢ºèªã—ã¦ã„ãã¾ã™ã€‚

Providerã«ã¯`Provider`ã®ä»–ã«ã€`FutureProvider`ã‚„`NotifierProvider`ãªã©ãŒå­˜åœ¨ã—ã¾ã™ã€‚ä»Šå›ã¯ã€Œã¨ã‚Šã‚ãˆãšå‡¦ç†ã‚’è¿½ã„ãŸã„ã€ã®ã§ã€`Provider`ã‚’ä¸­å¿ƒã«ç¢ºèªã—ã¾ã™ã€‚

| ã‚¯ãƒ©ã‚¹ | ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ | ç¶™æ‰¿ |
| :---: | :---: | :---: |
| [Provider](https://github.com/rrousselGit/riverpod/blob/riverpod-v2.3.1/packages/riverpod/lib/src/provider/base.dart#L19) | [riverpod](https://pub.dev/packages/riverpod) | `extends InternalProvider<T> with AlwaysAliveProviderBase<T>` |
| [AutoDisposeProvider](https://github.com/rrousselGit/riverpod/blob/riverpod-v2.3.1/packages/riverpod/lib/src/provider/auto_dispose.dart#L8) | [riverpod](https://pub.dev/packages/riverpod) | `extends InternalProvider<T>` |
| [InternalProvider](https://github.com/rrousselGit/riverpod/blob/riverpod-v2.3.1/packages/riverpod/lib/src/provider.dart#L15) | [riverpod](https://pub.dev/packages/riverpod) | `extends ProviderBase<T> with OverrideWithValueMixin<T>` |
| [ProviderBase](https://github.com/rrousselGit/riverpod/blob/riverpod-v2.3.1/packages/riverpod/lib/src/framework/provider_base.dart#L28) | [riverpod](https://pub.dev/packages/riverpod) | `extends ProviderOrFamily with ProviderListenable<T> implements ProviderOverride, Refreshable<T>` |
| [ProviderElementBase](https://github.com/rrousselGit/riverpod/blob/riverpod-v2.3.1/packages/riverpod/lib/src/framework/element.dart#L38) | [riverpod](https://pub.dev/packages/riverpod) | `implements Ref<T>, Node` |

### `ConsumerStatefulwWidget`ã¨`Provider`

`Provider`ã¯ã„ãã¤ã‚‚ã®ã‚¯ãƒ©ã‚¹ã‚’ç¶™æ‰¿ã€mixinã•ã‚Œã‚‹ã“ã¨ã§æˆã‚Šç«‹ã£ã¦ã„ã¾ã™ã€‚ä»Šå›ã¯ã€å®Ÿè£…ã®ä¸­å¿ƒã¨ãªã‚‹`ProviderBase`ã‚’ç¢ºèªã—ã¾ã™ã€‚
`ProviderBase`ã¯ä¸€è¦‹ã™ã‚‹ã¨èª­ã¿ã«ãã„ã®ã§ã™ãŒã€`ref.read`ã¨`ref.watch`ã§å‘¼ã³å‡ºã•ã‚Œã‚‹é–¢æ•°ã‚’ç¢ºèªã™ã‚‹ã“ã¨ã§ã€å‰²åˆç°¡å˜ã«æŠŠæ¡ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä»¥ä¸‹ã€æŠŠæ¡ç”¨ã«ã‚³ãƒ¼ãƒ‰ã‚’æŠœç²‹ã—ã¾ã™ã€‚

```dart
@immutable
abstract class ProviderBase<T> extends ProviderOrFamily with ProviderListenable<T> implements ProviderOverride, Refreshable<T> {
  @override
  ProviderSubscription<T> addListener(
    Node node,
    void Function(T? previous, T next) listener, {
    required void Function(Object error, StackTrace stackTrace)? onError,
    required void Function()? onDependencyMayHaveChanged,
    required bool fireImmediately,
  }) {
    onError ??= Zone.current.handleUncaughtError;

    final element = node.readProviderElement(this);

    element.flush();
    if (fireImmediately) {
      handleFireImmediately(
        element.getState()!,
        listener: listener,
        onError: onError,
      );
    }

    element._onListen();

    return node._listenElement(
      element,
      listener: listener,
      onError: onError,
    );
  }

  @override
  State read(Node node) {
    final element = node.readProviderElement(this);

    element.flush();

    // In case `read` was called on a provider that has no listener
    element.mayNeedDispose();

    return element.requireState;
  }
}
```

#### `ref.read`

`read`ã«ã¯`Node`ãŒç™»å ´ã—ã¾ã™ã€‚`ProviderContainer`ãŒ`Node`ã‚’implemntã—ã¦ã„ã‚‹ã“ã¨ã¨ã€`ConsumerStatefulWidget`ã§`ProviderScope.containerOf`ã‚’å‘¼ã³å‡ºã—ã¦ã„ãŸã“ã¨ã‚’æ€ã„å‡ºã›ã°ã€å‡¦ç†ã®æµã‚Œã¯æŠŠæ¡ã§ãã¾ã™ã­ã€‚

```dart
class ConsumerStatefulElement extends StatefulElement implements WidgetRef {
  @override
  T read<T>(ProviderListenable<T> provider) {
    return ProviderScope.containerOf(this, listen: false).read(provider);
  }
}

class ProviderScope extends StatefulWidget {
  /// Read the current [ProviderContainer] for a [BuildContext].
  static ProviderContainer containerOf(
    BuildContext context, {
    bool listen = true,
  }) {
    UncontrolledProviderScope? scope;

    if (listen) {
      scope = context //
          .dependOnInheritedWidgetOfExactType<UncontrolledProviderScope>();
    } else {
      scope = context
          .getElementForInheritedWidgetOfExactType<UncontrolledProviderScope>()
          ?.widget as UncontrolledProviderScope?;
    }

    if (scope == null) {
      throw StateError('No ProviderScope found');
    }

    return scope.container;
  }
}

class ProviderContainer implements Node {
  Result read<Result>(
    ProviderListenable<Result> provider,
  ) {
    return provider.read(this);
  }
}

@immutable
abstract class ProviderBase<T> extends ProviderOrFamily
    with ProviderListenable<T>
    implements ProviderOverride, Refreshable<T> {

  @override
  State read(Node node) {
    final element = node.readProviderElement(this);

    element.flush();

    // In case `read` was called on a provider that has no listener
    element.mayNeedDispose();

    return element.requireState;
  }
}
```

`ProviderContainer`ã®`read`ãŒã€Œå¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚ŒãŸ`provider`ã®`read`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹ã€ãŸã‚æ··ä¹±ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚é †ã‚’è¿½ã£ã¦èª­ã‚“ã§ã„ãã¨ã€`Node`ã«å¯¾ã—ã¦`ProviderBase<T>`ã‚’æ¸¡ã—ã¦ã„ã‚‹ã“ã¨ãŒæŠŠæ¡ã§ãã¾ã™ã€‚
`readProviderElement`ã®å®Ÿè£…ã¯ã€`Node`ã‚’implementã—ã¦ã„ã‚‹`ProviderContainer`ã«ã‚ã‚Šã¾ã™ã€‚

```dart
class ProviderContainer implements Node {
  @override
  ProviderElementBase<T> readProviderElement<T>(
    ProviderBase<T> provider,
  ) {
    if (_disposed) {
      throw StateError(
        'Tried to read a provider from a ProviderContainer that was already disposed',
      );
    }

    final reader = _getStateReader(provider);

    return reader.getElement() as ProviderElementBase<T>;
  }
}
```

`_getStateReader(provider)`ã®å†…å®¹ã‚’çŸ­ãã¾ã¨ã‚ã‚‹ã®ã¯é›£ã—ã„ã®ã§ã™ãŒã€ãŠãŠã‚ˆãã€Œ`provider`ã«å¯¾å¿œã™ã‚‹`_StateReader`ã‚’ç”Ÿæˆ/ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã€ã—ã¦ã„ã‚‹é–¢æ•°ã ã¨è¨€ãˆã¾ã™ã€‚ãã—ã¦`_StateReader`ã¯`ProviderElementBase`ã‚’ç”Ÿæˆ/ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã‚‹ã‚¯ãƒ©ã‚¹ã§ã™ã€‚
`ProviderElementBase`ã¯æ­£ç›´è¿½ã„ã‹ã‘ã‚‹ã®ãŒé›£ã—ã„ã‚¯ãƒ©ã‚¹ãªã®ã§ã€ä¸‹è¨˜ã®ã‚³ãƒ¼ãƒ‰ã‚’ã–ã£ã¨çœºã‚ã€`Result<T>?`ã‚’ç®¡ç†ã—ã¦ã„ã‚‹ã“ã¨ã‚’æŠŠæ¡ã—ã¦ã¿ã¦ãã ã•ã„ã€‚

```dart
/// An internal class that handles the state of a provider.
///
/// Do not use.
abstract class ProviderElementBase<T> implements Ref<T>, Node {
  /// Do not use.
  ProviderElementBase(this._provider);

  /* STATE */
  Result<T>? _state;

  /// Update the exposed value of a provider and notify its listeners.
  ///
  /// Listeners will only be notified if [updateShouldNotify]
  /// returns true.
  ///
  /// This API is not meant for public consumption. Instead if a [Ref] needs
  /// to expose a way to update the state, the practice is to expose a getter/setter.
  @protected
  void setState(T newState) {
    final previousResult = getState();
    final result = _state = ResultData(newState);

    if (_didBuild) {
      _notifyListeners(result, previousResult);
    }
  }

  /// Obtains the current state, of null if the provider has yet to initialize.
  ///
  /// The returned object will contain error information, if any.
  /// This function does not cause the provider to rebuild if it someohow was
  /// outdated.
  ///
  /// This is not meant for public consumption. Instead, public API should use
  /// [readSelf].
  @protected
  @visibleForTesting
  Result<T>? getState() => _state;

  /// A utility for re-initializing a provider when needed.
  ///
  /// Calling [flush] will only re-initialize the provider if it needs to rerun.
  /// This can involve:
  /// - a previous call to [invalidateSelf]
  /// - a dependency of the provider has changed (such as when using [watch]).
  ///
  /// This is not meant for public consumption. Public API should hide
  /// [flush] from users, such that they don't need to care about invocing this function.
  void flush() {
    _maybeRebuildDependencies();
    if (_mustRecomputeState) {
      _mustRecomputeState = false;
      _performBuild();
    }
  }
}
```

`Provider`ã§ã¯`ProviderElementBase`ã‚’ç¶™æ‰¿ã—ãŸ`ProviderElement`ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚

```dart
class ProviderElement<T> extends ProviderElementBase<T> implements ProviderRef<T> {
  /// A [ProviderElementBase] for [Provider]
  ProviderElement._(super.provider);

  @override
  T get state => requireState;

  @override
  set state(T newState) => setState(newState);

  @override
  void create({required bool didChangeDependency}) {
    final provider = this.provider as InternalProvider<T>;

    setState(provider._create(this));
  }

  @override
  bool updateShouldNotify(T previous, T next) {
    return previous != next;
  }
}
```

`ProviderElement`ã®`create`ã¯ã€`mount()`ã‹`flush()`ã®ä¸­ã§å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚`mount()`ã¯`_StateReader`ã®`getElement()`ãŒåˆã‚ã¦å‘¼ã°ã‚Œã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã€`flush()`ã¯(ã“ã“ã§ã¯)`ProviderBase`ã®`read`ãŒå‘¼ã°ã‚Œã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã™ã€‚ã“ã‚Œã§ã€`ref.read`ã®å‘¼ã³å‡ºã—ãŒã•ã‚ŒãŸéš›ã«`Provider`ã®å¼•æ•°ã¨ã—ã¦ä¸ãˆãŸå‡¦ç†ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãŒã‚ã‹ã‚Šã¾ã—ãŸï¼

#### `ref.watch`

ç¶šã„ã¦ã€`ref.watch`ã®ã‚±ãƒ¼ã‚¹ã‚‚ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚`read`ã®ã‚±ãƒ¼ã‚¹ã§è¦‹æ…£ã‚ŒãŸã‚¯ãƒ©ã‚¹ãŒå¤šããªã‚‹ãŸã‚ã€ã“ã“ã¾ã§èª­ã¿é€²ã‚ãŸæ–¹ãªã‚‰ã°ã€ãã“ã¾ã§è‹¦åŠ´ã¯ãªã„ã¯ãšã§ã™ã€‚

```dart
class ConsumerStatefulElement extends StatefulElement implements WidgetRef {
  late ProviderContainer _container = ProviderScope.containerOf(this);
  
  @override
  Res watch<Res>(ProviderListenable<Res> target) {
    return _dependencies.putIfAbsent(target, () {
      final oldDependency = _oldDependencies?.remove(target);

      if (oldDependency != null) {
        return oldDependency;
      }

      return _container.listen<Res>(
        target,
        (_, __) => markNeedsBuild(),
      );
    }).read() as Res;
  }
}

class ProviderContainer implements Node {
  @override
  ProviderSubscription<T> listen<T>(
    ProviderListenable<T> provider,
    void Function(T? previous, T next) listener, {
    bool fireImmediately = false,
    void Function(Object error, StackTrace stackTrace)? onError,
  }) {
    return provider.addListener(
      this,
      listener,
      fireImmediately: fireImmediately,
      onError: onError,
      onDependencyMayHaveChanged: null,
    );
  }

  @override
  ProviderSubscription<T> _listenElement<T>(
    ProviderElementBase<T> element, {
    required void Function(T? previous, T next) listener,
    required void Function(Object error, StackTrace stackTrace) onError,
  }) {
    final sub = _ExternalProviderSubscription<T>._(
      element,
      listener,
      onError: onError,
    );

    element._externalDependents.add(sub);

    return sub;
  }
}

abstract class ProviderBase<T> extends ProviderOrFamily with ProviderListenable<T> implements ProviderOverride, Refreshable<T> {
  @override
  ProviderSubscription<T> addListener(
    Node node,
    void Function(T? previous, T next) listener, {
    required void Function(Object error, StackTrace stackTrace)? onError,
    required void Function()? onDependencyMayHaveChanged,
    required bool fireImmediately,
  }) {
    onError ??= Zone.current.handleUncaughtError;

    final element = node.readProviderElement(this);

    element.flush();
    if (fireImmediately) {
      handleFireImmediately(
        element.getState()!,
        listener: listener,
        onError: onError,
      );
    }

    element._onListen();

    return node._listenElement(
      element,
      listener: listener,
      onError: onError,
    );
  }
}

abstract class ProviderElementBase<T> implements Ref<T>, Node {
  void _onListen() {
    _onAddListeners?.forEach(runGuarded);
    if (_didCancelOnce && !hasListeners) {
      _onResumeListeners?.forEach(runGuarded);
    }
  }
}

/// Represents the subscription to a [ProviderListenable]
abstract class ProviderSubscription<T> {
  /// Stops listening to the provider
  @mustCallSuper
  void close();

  /// Obtain the latest value emitted by the provider
  T read();
}

class _ExternalProviderSubscription<T> implements ProviderSubscription<T> {
  /// çœç•¥
}
```

`ref.watch`ã¯`ref.read`ã¨åŒã˜ã‚ˆã†ã«`ProviderElementBase`ã§`Result<T>?`ã‚’ä¿æŒã—ã¤ã¤ã€å¤‰æ›´ãŒã‚ã£ãŸå ´åˆã«ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å—ã‘å–ã‚‹ã‚ˆã†ãªå®Ÿè£…ã«ãªã£ã¦ã„ã¾ã™ã€‚`ProviderElementBase._onListen`ã®è©³ç´°ã«ã¤ã„ã¦ã¯ã€æ¬¡ã®`AutoDisposeProvider`ã§ç¢ºèªã—ã¦ã„ãã®ã§ã€ä¸€æ—¦çœºã‚ã‚‹ç¨‹åº¦ã¨ã—ã¦ã¿ã¦ãã ã•ã„ã€‚
`ConsumerStatefulElement`ã§ã¯ã€listenerãŒå‹•ããŸã³ã«`markNeedsBuild()`ã‚’ã‚»ãƒƒãƒˆã—ã¦ã„ã¾ã™ã€‚ã“ã®å‡¦ç†ã«ã‚ˆã‚Šã€`ref.watch`ã§ç›£è¦–ã—ã¦ã„ã‚‹`Reulst`ã«å¤‰æ›´ãŒã‚ã£ãŸã¨ãã€`ConsumerStatefulWidget`ã‚’ç¶™æ‰¿ã—ã¦ã„ã‚‹ã‚¯ãƒ©ã‚¹ã®`build`é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

### `AutoDisposeProvider`

### `keepAlive`
