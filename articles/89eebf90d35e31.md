---
title: "Flutterの例外ハンドリングの仕組みを読む"
emoji: "⚾️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [
  "flutter",
  "dart",
]
published: true
published_at: "2025-10-14 09:00"
---

アプリを運用する上で、例外(Exception)の発生状況を確認することは非常に重要です。このため、多くのプロジェクトでは[firebase_crashlytics](https://pub.dev/packages/firebase_crashlytics)や[sentry_flutter](https://pub.dev/packages/sentry_flutter)などの例外収集ツールを導入していると思います。

これらのツールのドキュメントを読むと、`FlutterError.onError`や`runZonedGuarded`が登場します。ドキュメント内のコメントなどを読むと、アプリケーション内でキャッチしなかった例外、つまり`try-catch`で捕捉されなかった例外を拾うことができるようです。

https://firebase.google.com/docs/crashlytics/get-started?platform=flutter

> You can automatically catch all errors that are thrown within the Flutter framework by overriding `FlutterError.onError` with `FirebaseCrashlytics.instance.recordFlutterFatalError`:

```dart
void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  await Firebase.initializeApp();

  // Pass all uncaught "fatal" errors from the framework to Crashlytics
  FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterFatalError;

  runApp(MyApp());
}
```

> To catch asynchronous errors that aren't handled by the Flutter framework, use `PlatformDispatcher.instance.onError`:

```dart
Future<void> main() async {
    WidgetsFlutterBinding.ensureInitialized();
    await Firebase.initializeApp();
    FlutterError.onError = (errorDetails) {
      FirebaseCrashlytics.instance.recordFlutterFatalError(errorDetails);
    };
    // Pass all uncaught asynchronous errors that aren't handled by the Flutter framework to Crashlytics
    PlatformDispatcher.instance.onError = (error, stack) {
      FirebaseCrashlytics.instance.recordError(error, stack, fatal: true);
      return true;
    };
    runApp(MyApp());

}
```

https://pub.dev/packages/sentry_flutter

> The SDK already runs your init `callback` on an error handler, such as [runZonedGuarded](https://api.flutter.dev/flutter/dart-async/runZonedGuarded.html) on Flutter versions prior to `3.3`, or [PlatformDispatcher.onError](https://api.flutter.dev/flutter/dart-ui/PlatformDispatcher/onError.html) on Flutter versions 3.3 and higher, so that errors are automatically captured.

```dart
import 'package:flutter/widgets.dart';
import 'package:sentry_flutter/sentry_flutter.dart';

Future<void> main() async {
  await SentryFlutter.init(
    (options) {
      options.dsn = 'https://example@sentry.io/add-your-dsn-here';
    },
    // Init your App.
    appRunner: () => runApp(MyApp()),
  );
}
```

Flutterにおけるエラーハンドリングについては、ぜひ一度公式ドキュメントを確認しましょう。本記事で得られる知見も、よりコンパクトにまとまっています。

https://docs.flutter.dev/testing/errors

本記事の趣旨は、上記のドキュメントを理解するために、Flutterのソースコードを確認する点にあります。`FlutterError.onError`と`PlatformDispatcher.instance.onError`がどのような仕組みになっているのか、ソースコードを読んで理解してみましょう。

## (前準備)Firebase Crashlyticsのドキュメントを読む

https://firebase.google.com/docs/crashlytics/customize-crash-reports?platform=flutter

Firebase Crashlyticsの公式ドキュメントをよく読んでみると、次の2点が書かれています。

1. 非同期処理内での例外はFlutter frameworkではキャッチされない
   * このため、`PlatformDispatcher.instance.onError`でキャッチする必要がある
2. 別の`Isolate`を作成している場合、その`Isolate`内で発生した例外はFlutter frameworkではキャッチされない
   * このため、`Isolate`に対してerror listenersを登録する必要がある

Firebase Crashlyticsのドキュメントに書かれているサンプルは、この2つの振る舞いを踏まえた上の実装です。また「アプリ内でハンドリングされなかった例外はfatalとして扱う」というポリシーも読み取れます。
この点は、Firebase Crashlyticsを使う際の注意点として重要です。というのも、non-fatalな例外は(non-fatalであるが故に)優先度が明確に低い例外として扱われます。

> In addition to automatically reporting your app’s crashes, Crashlytics lets you record non-fatal exceptions and sends them to you the next time a fatal event is reported or when the app restarts.

であり、

> Note: Crashlytics only stores the most recent eight recorded non-fatal exceptions. If your app throws more than eight, older exceptions are lost. This count is reset each time a fatal exception is thrown, since this causes a report to be sent to Crashlytics.

と記述されています。non-fatalな例外を8件までしか保存せず、fatalな例外が発生した際にnon-fatalな例外を送信する仕組みのため、non-fatalな例外を多用すると検知できない恐れがあります。ただfatalな例外はベロシティアラートの対象となるため、上に送信するとオオカミ少年になりかねません。
このような事情から、Firebase Crashlyticsを利用する場合には、Flutterにおける例外の扱いを正しく理解しておくことが重要です。

## `FlutterError.onError`の仕組み

まず、`FlutterError.onError`がどのような実装になっているのか確認しましょう。Flutterのソースコードを読みにいくと、`/packages/flutter/lib/src/foundation/assertions.dart`に定義されています。

https://github.com/flutter/flutter/blob/3.35.6/packages/flutter/lib/src/foundation/assertions.dart#L755-L1205

該当の実装を抜き出します。Flutter SDKのバージョンは3.35.6です。

```dart
/// Signature for [FlutterError.onError] handler.
typedef FlutterExceptionHandler = void Function(FlutterErrorDetails details);

/// Error class used to report Flutter-specific assertion failures and
/// contract violations.
///
/// See also:
///
///  * <https://docs.flutter.dev/testing/errors>, more information about error
///    handling in Flutter.
class FlutterError extends Error with DiagnosticableTreeMixin implements AssertionError {

  /// Called whenever the Flutter framework catches an error.
  ///
  /// The default behavior is to call [presentError].
  ///
  /// You can set this to your own function to override this default behavior.
  /// For example, you could report all errors to your server. Consider calling
  /// [presentError] from your custom error handler in order to see the logs in
  /// the console as well.
  ///
  /// If the error handler throws an exception, it will not be caught by the
  /// Flutter framework.
  ///
  /// Set this to null to silently catch and ignore errors. This is not
  /// recommended.
  ///
  /// Do not call [onError] directly, instead, call [reportError], which
  /// forwards to [onError] if it is not null.
  ///
  /// See also:
  ///
  ///  * <https://docs.flutter.dev/testing/errors>, more information about error
  ///    handling in Flutter.
  static FlutterExceptionHandler? onError = presentError;

  /// Called whenever the Flutter framework wants to present an error to the
  /// users.
  ///
  /// The default behavior is to call [dumpErrorToConsole].
  ///
  /// Plugins can override how an error is to be presented to the user. For
  /// example, the structured errors service extension sets its own method when
  /// the extension is enabled. If you want to change how Flutter responds to an
  /// error, use [onError] instead.
  static FlutterExceptionHandler presentError = dumpErrorToConsole;

  /// Calls [onError] with the given details, unless it is null.
  ///
  /// {@tool snippet}
  /// When calling this from a `catch` block consider annotating the method
  /// containing the `catch` block with
  /// `@pragma('vm:notify-debugger-on-exception')` to allow an attached debugger
  /// to treat the exception as unhandled. This means instead of executing the
  /// `catch` block, the debugger can break at the original source location from
  /// which the exception was thrown.
  ///
  /// ```dart
  /// @pragma('vm:notify-debugger-on-exception')
  /// void doSomething() {
  ///   try {
  ///     methodThatMayThrow();
  ///   } catch (exception, stack) {
  ///     FlutterError.reportError(FlutterErrorDetails(
  ///       exception: exception,
  ///       stack: stack,
  ///       library: 'example library',
  ///       context: ErrorDescription('while doing something'),
  ///     ));
  ///   }
  /// }
  /// ```
  /// {@end-tool}
  static void reportError(FlutterErrorDetails details) {
    onError?.call(details);
  }
}
```

`FlutterError.onError`は、見た目の通りstaticなプロパティです。コメントにある通り、開発者によって上書きされることを想定しています。また、`FlutterError.reportError`を呼び出すことで、`FlutterError.onError`に登録されている関数が呼び出される仕組みです。

Flutter SDKに対して`FlutterError.reportError`の呼び出し箇所を検索してみると、`ChangeNotifier`の`notifyListeners`の呼び出し時に例外が発生した箇所やImageの`precacheImage`において例外が発生した箇所など、フレームワークの各所で呼び出されていることがわかります。コードを読む限り、どこかで一括して`FlutterError.reportError`が呼び出されているわけではなく、例外が発生しうる箇所で個別に`FlutterError.reportError`が呼び出されているようです。

呼び出されるべき箇所で呼び出されているとすれば、`FlutterError.onError`の仕組みは非常にシンプルです。
`FlutterError.reportError`が呼び出されると、`FlutterError.onError`に登録されている関数が呼び出されます。デフォルトでは`FlutterError.presentError`が登録されており、さらにそのデフォルト実装は`FlutterError.dumpErrorToConsole`です。つまり、開発者が書いたコード内でキャッチされなかった例外は、最終的にコンソールに出力されることになります。覚えがある動きです。
また、Firebase Crashlyticsなどで紹介されている仕組みにも、一定の納得感があります。`FlutterError.onError`にCrashlyticsの関数を登録しておけば、開発者がキャッチしなかった例外、つまりUncaught ExceptionをCrashlyticsに送信できます。

## `PlatformDispatcher.instance.onError`の仕組み

続いて、`PlatformDispatcher.instance.onError`がどのような実装になっているのか確認しましょう。Flutterのソースコードを読みにいくと、`/engine/src/flutter/lib/ui/platform_dispatcher.dart`に定義されています。`/packages/flutter`ではなく`/engine/src/flutter/lib/ui`にあることに注意してください。

https://github.com/flutter/flutter/blob/3.35.6/engine/src/flutter/lib/ui/platform_dispatcher.dart#L104-L1524

該当の実装を抜き出します。こちらも、Flutter SDKのバージョンは3.35.6です。

```dart
/// Signature for [PlatformDispatcher.onError].
///
/// If this method returns false, the engine may use some fallback method to
/// provide information about the error.
///
/// After calling this method, the process or the VM may terminate. Some severe
/// unhandled errors may not be able to call this method either, such as Dart
/// compilation errors or process terminating errors.
typedef ErrorCallback = bool Function(Object exception, StackTrace stackTrace);

/// Platform event dispatcher singleton.
///
/// The most basic interface to the host operating system's interface.
///
/// This is the central entry point for platform messages and configuration
/// events from the platform.
///
/// It exposes the core scheduler API, the input event callback, the graphics
/// drawing API, and other such core services.
///
/// It manages the list of the application's [views] as well as the
/// [configuration] of various platform attributes.
///
/// Consider avoiding static references to this singleton through
/// [PlatformDispatcher.instance] and instead prefer using a binding for
/// dependency resolution such as `WidgetsBinding.instance.platformDispatcher`.
/// See [PlatformDispatcher.instance] for more information about why this is
/// preferred.
class PlatformDispatcher {

  /// The [PlatformDispatcher] singleton.
  ///
  /// Consider avoiding static references to this singleton through
  /// [PlatformDispatcher.instance] and instead prefer using a binding for
  /// dependency resolution such as `WidgetsBinding.instance.platformDispatcher`.
  ///
  /// Static access of this object means that Flutter has few, if any options to
  /// fake or mock the given object in tests. Even in cases where Dart offers
  /// special language constructs to forcefully shadow such properties, those
  /// mechanisms would only be reasonable for tests and they would not be
  /// reasonable for a future of Flutter where we legitimately want to select an
  /// appropriate implementation at runtime.
  ///
  /// The only place that `WidgetsBinding.instance.platformDispatcher` is
  /// inappropriate is if access to these APIs is required before the binding is
  /// initialized by invoking `runApp()` or
  /// `WidgetsFlutterBinding.instance.ensureInitialized()`. In that case, it is
  /// necessary (though unfortunate) to use the [PlatformDispatcher.instance]
  /// object statically.
  static PlatformDispatcher get instance => _instance;
  static final PlatformDispatcher _instance = PlatformDispatcher._();

  ErrorCallback? _onError;
  Zone? _onErrorZone;

  /// A callback that is invoked when an unhandled error occurs in the root
  /// isolate.
  ///
  /// This callback must return `true` if it has handled the error. Otherwise,
  /// it must return `false` and a fallback mechanism such as printing to stderr
  /// will be used, as configured by the specific platform embedding via
  /// `Settings::unhandled_exception_callback`.
  ///
  /// The VM or the process may exit or become unresponsive after calling this
  /// callback. The callback will not be called for exceptions that cause the VM
  /// or process to terminate or become unresponsive before the callback can be
  /// invoked.
  ///
  /// This callback is not directly invoked by errors in child isolates of the
  /// root isolate. Programs that create new isolates must listen for errors on
  /// those isolates and forward the errors to the root isolate.
  ErrorCallback? get onError => _onError;
  set onError(ErrorCallback? callback) {
    _onError = callback;
    _onErrorZone = Zone.current;
  }

  bool _dispatchError(Object error, StackTrace stackTrace) {
    if (_onError == null) {
      return false;
    }
    assert(_onErrorZone != null);

    if (identical(_onErrorZone, Zone.current)) {
      return _onError!(error, stackTrace);
    } else {
      try {
        return _onErrorZone!.runBinary<bool, Object, StackTrace>(_onError!, error, stackTrace);
      } catch (e, s) {
        _onErrorZone!.handleUncaughtError(e, s);
        return false;
      }
    }
  }
}
```

`PlatformDispatcher.instance._dispatchError`の呼び出し箇所は、もう少しコードをジャンプしていく必要があります。検索すると`flutter/engine/src/flutter/lib/ui/hooks.dart`で呼び出されており、

https://github.com/flutter/flutter/blob/3.35.6/engine/src/flutter/lib/ui/hooks.dart#L305-L308

Dartのコードとしては、これ以上の呼び出しはありません。この`_onError`はEngineのC++のコードから、Dartのコードを呼び出すために用意されています。

https://github.com/flutter/flutter/blob/3.35.6/engine/src/flutter/lib/ui/window/platform_configuration.cc#L40-L44

https://github.com/flutter/flutter/blob/3.35.6/engine/src/flutter/lib/ui/window/platform_configuration.h#L553

ここから先は筆者がC++に明るくない&FlutterのC++コードに精通していないため、詳細は割愛します。[導入したPR](https://github.com/flutter/engine/pull/32078)を読む限りでは、フレームワークでキャッチされなかった例外を、Dartのコードでキャッチするよう実装されているようです。なお、Flutter Webでは`PlatformDispatcher.instance.onError`の仕組みは実装途中のようです。詳細は次のIssueを参照してください。

https://github.com/flutter/flutter/issues/100277

https://github.com/flutter/flutter/blob/3.35.6/engine/src/flutter/lib/web_ui/lib/src/engine/platform_dispatcher.dart#L1231-L1242

### `runZonedGuarded`との違い

[design doc](https://docs.google.com/document/d/1HdGLKoVw_KWLrVzDNZ8Lk5nN-biHQzi_CS5mCkpiDwA/edit?tab=t.0#heading=h.pub7jnop54q0)を(ざっくり)読むと、「Dartでエラーハンドリングを簡単にする」ことに焦点が置かれていたようです。

また、`runZonedGuarded`では複数の`Zone`で起きた例外をキャッチすることはできますが、Dart VMの外で起きた例外をキャッチすることはできません。一方、`PlatformDispatcher.instance.onError`はC++のコード内でキャッチした例外をDartのコードに伝搬できるため、Dart VMの外で起きた例外もキャッチできるようです。結果として、`Future`内で発生した非同期処理中の例外以外のケースにも、Dartのコードとしてはシンプルなままで対応できるようになった、と筆者は現時点で理解しています。

## まとめ

ざっとではありますが、Flutter SDKのソースコードを読むことで、Flutterの"未処理の"例外をキャッチする仕組みを把握できたのではないでしょうか。また、なぜFlutterのコード内で`Exception`が発生しても、Flutterのアプリがクラッシュしないことがあるのか、その理由も理解できたと思います。

とは言え、多くの場合、Firebase Crashlyticsのドキュメントのコメントに書いてある理解で十分なはずです。`FlutterError.onError`は**Pass all uncaught "fatal" errors from the framework**をキャッチ、`PlatformDispatcher.instance.onError`は**Pass all uncaught asynchronous errors that aren't handled by the Flutter framework**をキャッチ、この理解で問題ありません。

ただ、これは「Firebase Crashlytcsから見ると」という前提がついていることは、記事を読んでいただいた方には伝わっていると思います。
AndroidやiOSのネイティブアプリの場合、アプリクラッシュを伴うものをfatal、アプリクラッシュを伴わないものをnon-fatalとして扱うことが多かったと思います。しかしFlutterにおいては、try-catchで捕捉されなかった例外がfatal、try-catchで捕捉され送信された例外がnon-fatalとして(Firebase Crashlyticsのドキュメント通りの実装の場合)扱われます。この違いを考慮するためには、Flutterの例外ハンドリングの仕組みを正しく理解しておく必要があります。

---

`FlutterError.onError`と`PlatformDispatcher.instance.onError`を使いこなすことで、より適切な例外ハンドリングが可能になります。現実的にはクラッシュを監視するサービスに例外を送信するだけになるかと思いますが、ぜひ、思いを馳せてみてください。
