---
title: "Paging処理とFlutter(とpaging_viewパッケージ)"
emoji: "📄"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["flutter", "dart", "paging",]
published: true
published_at: "2025-12-09 07:00"
---

この記事は[Flutter Advent Calendar 2025](https://qiita.com/advent-calendar/2025/flutter)の12月9日分の記事です。
いわゆる無限スクロールについて書きます。

## はじめに

アプリを作っていると、どこかで無限スクロールを実装する必要に迫られます。筆者の体感では、1アプリあたり1.5回程度の頻度です。

しかし、無限スクロールの実装はそこまで気楽に取り組めるものではありません。Material Componentsだけで実装を試みると、実装自体はできるものの、しっくりこない実装になってしまいがちです。また、動作確認をすると思ったように動かないなど、ハマりどころも多数存在します。

本記事では、いわゆる無限スクロールの実装のために、**Paging処理**を整理します。併せて、筆者が趣味で開発している[paging_view](https://pub.dev/packages/paging_view)パッケージについて紹介することを通して、Flutterにおける柔軟なPaging処理の実装方法について説明します。

## Paging API

十分に大きなデータ、もしくは無限に続くデータを扱う場合、全てのデータを一度に読み込むことは非効率的です。そのため、分割して読み込む必要があります。特にモバイル環境では、ネットワーク帯域やメモリの制約があるため、データを10〜20件ずつサーバーから取得することが一般的です。

このような処理では、分割されたデータのことを「ページ」と呼びます。各ページには、通常、固定数のアイテムと次のページを取得するための情報が含まれています。

### Keyのタイプ

Paging APIのkeyは、いくつかのパターンがあります。

一番シンプルなのは、要素の順序をそのまま使うパターンです。1ページ目は要素を追加した順で最初の20、2ページ目は21〜40といった具合です。当然、keyはページ数であり整数値になります。メリットは実装が簡単な点ですが、リアルタイムで要素の追加や削除が発生するケースでは正しくページングできないデメリットがあります。とはいえ、Google検索のように、順序が変わったとしても許容されるケースでは有効です。

要素に対して一意な値をKeyとして使うケースもあります。読書記録のようなデータであれば、日時をKeyとしても良いでしょう。この場合、APIは「指定した日時よりも新しい/古いデータをN件取得する」といった形になります。一方、いわゆるSNSのタイムラインのようなケースでは、投稿日時をKeyに使うと、同じ日時に複数の投稿がある場合に正しくページングできないデメリットがあります。

これらのメリットとデメリットを整理すると、要素に対して一意なIDを与え、そのIDをKeyとして使うのが最も汎用的です。ページの取得時に、「指定したIDよりも新しい/古いデータをN件取得する」といった形とすることで、リアルタイムで要素の追加や削除が発生しても正しくページングできます。サーバー側で作成日時などの順序を保持した上で、クライアントから渡されたIDを基準に検索する必要があります。

### 追加取得のタイミング

Paging処理では、ユーザーがスクロールしてリストの末尾に近づいたとき、次のページを自動的に取得するケース。もしくは、末尾に次のページの取得をリクエストするボタンなどを設置し、ユーザーが明示的に次のページを取得するケースがあります。いわゆる無限スクロールは前者のケース、後者のケースは「もっと見る」ボタンのケースです。

それぞれのケースにはメリットとデメリットがあります。

自動的に次のページを取得するケースでは、ユーザーはシームレスにコンテンツを閲覧できますが、データ取得が余計に発生するかもしれません。明示的に次のページを取得するケースでは無駄なデータ通信を避けられますが、逐一ボタンをタップするのは不快かもしれません。アプリや機能の性質、想定されるユーザーの行動に応じて、適切な方法を選択することが重要です。

### スクロールのパフォーマンス

ページング処理を行う必要があるのは、大量のデータがある場合です。そもそもページング処理は『大量のデータを限られたリソースの中でどう扱うか』という課題への対応そのものです。現代のモバイル端末では、数千件程度のデータであればメモリ上に保持しても大抵問題はないのですが、しかしどこかに限界があります。

大量のデータをメモリ上に保持すると、アプリケーションのパフォーマンスが低下し、最悪の場合クラッシュする可能性があります。また、無限に表示される全てのViewをメモリ上に保持すると、同様にパフォーマンスの低下やクラッシュの原因となります。これはデータの量に起因するため、いくらViewの再利用しても解決できません。

https://developer.android.com/topic/libraries/architecture/paging/v3-overview?hl=ja

筆者の知る限り、この問題に対して最も洗練された解決策を提供しているのがAndroidのPaging 3ライブラリです。このライブラリはページごとにデータを読み込むだけでなく、メモリ上に保持する最大ページ数を制御し、それ以上のページをメモリから破棄する仕組みを持っています。さらに[RemoteMediator](https://developer.android.com/topic/libraries/architecture/paging/v3-network-db?hl=ja)を使って[Room](https://developer.android.com/training/data-storage/room?hl=ja)と連携することで、破棄されたページをローカルデータベースから再取得できるようになります。この設計にすることで、ほぼ**無限**スクロールを実現します。^[端末のストレージ容量には依存しますが、モバイル端末においては事実上無限と考えて良いでしょう]

また、Viewにおいてもメモリ枯渇を防ぐ必要があります。Androidでは[LazyColumn](https://developer.android.com/jetpack/compose/lists?hl=ja#lazy-column)、Flutterでは[SliverList.builder](https://api.flutter.dev/flutter/widgets/SliverList/SliverList.builder.html)など、大量の要素を描画できるWidgetが用意されています。これらのWidgetを適切に利用することで、スクロールパフォーマンスを維持しつつ、大量のデータを効率的に表示できます。Flutterにおける工夫は、次のzenn記事が参考になります。

https://zenn.dev/3ta/articles/5a439a8f0c4b62

なお、Flutterの`ListView`は`CustomScrollView`と`SliverList`が組み合わさったWidgetです。複数のSliverを組み合わせたい場合には`CustomScrollView`一択になりますが、単にリストを表示したい場合には`ListView`を使う方がシンプルです。しかし、その実態に大きな違いはありません。本記事では`CustomScrollView`とSliverを中心に説明しますが、`ListView`でも同様の考え方が適用できます。

## `paging_view`パッケージ

https://pub.dev/packages/paging_view

`paging_view`パッケージは、AndroidのPaging 3っぽい実装を試してみたかった筆者が、趣味で開発しているパッケージです。基本的な考え方はAndroidのPaging 3と似ていますが、`RemoteMediator`のようなローカルデータベースの実現には依存関係が増えてしまうため、あえて実装していません。v2.6.0現在、依存しているパッケージは`flutter`と`collection`のみです。`collection`はFlutter SDKに含まれているため、実質的に外部依存はありません。

### 基本的な使い方

`DataSource`クラスを継承し、APIに応じたページング処理を実装します。

https://github.com/koji-1009/paging_view/blob/2.5.2/example/lib/model/data_source_list_repositories.dart#L18-L42

`load`メソッドには、UI操作によって発生するページングの要求が渡されます。`LoadAction`は次の継承クラスを持つ`sealed class`です。

* `Refresh`
* `Prepend(key: Key key)`
* `Append(key: Key key)`

アクションは「今回どのタイプのリクエストを行うか」と「前回のページングで取得した最後のKey」を含みます。`Refresh`は初回読み込みやリストの更新要求、`Prepend`はリストの先頭方向への追加読み込み、`Append`はリストの末尾方向への追加読み込みです。この`DataSource`を`PagingList`や`SliverPagingList`といったWidgetに渡すことで、Widgetの状態に応じたページング処理が実行されます。

### 設計について

`paging_view`は`ValueNotifier`と`ValueListenableBuilder`、`SliverMainAxisGroup`、そして`RenderSliver`を活用したライブラリです。ここでは、特に`RenderSliver`を活用した部分について説明します。

https://github.com/koji-1009/paging_view/blob/2.6.0/lib/src/private/sliver_bounds_detector.dart

`SliverBoundsDetector`は「`CustomScrollView`の中で描画されるようになる」タイミングで`onVisibilityChanged`コールバックを呼び出すSliverです。[VisibilityDetector](https://pub.dev/packages/visibility_detector)と異なり、`SliverBoundsDetector`は`CustomScrollView`内で[cacheExtent](https://api.flutter.dev/flutter/widgets/ScrollView/cacheExtent.html)を含む領域に入ったタイミングを検出します。このため「そろそろスクロールがリストの末端に届きそう」というタイミングでコールバックを呼び出すことができます。^[実装には苦労しましたが、AIのサポートもあり実装できました]

この`SliverBoundsDetector`を活用することで、ページング処理の実装がシンプルになります。というのも、実態は単なる[LeafRenderObjectWidget](https://api.flutter.dev/flutter/widgets/LeafRenderObjectWidget-class.html)と[RenderSliver](https://api.flutter.dev/flutter/rendering/RenderSliver-class.html)です。このため他のSliverと同じように`CustomScrollView`内に配置でき、宣言的にスクロール時の動作を定義できます。

次のコードは、縦に1行リストを表示する`SliverPagingList`です。

https://github.com/koji-1009/paging_view/blob/2.6.0/lib/src/widget/sliver_paging_list.dart#L230-L276

`SliverList.separated`の前後に`SliverBoundsDetector`を配置しています。リストの末尾方向に向かってのリストであれば、このような実装で十分です。^[先頭方向の読み込みについては後述]また、発火させるかさせないかの切り替えも、配列に対する`if`で簡単に制御できます。

### パフォーマンス

特に`CustomScrollView`とSliverの組み合わせは、大量のデータを効率的に表示するための強力なツールです。`paging_view`パッケージは、Flutterのこの特性を最大限に活用しています。Sliverが高速に描画できる状態であれば、`paging_view`も高速に動作します。

一方、`paging_view`ではリストの要素をメモリ上に保持しています。AndroidのPaging 3のように、メモリ上に保持するページ数を制御し、不要なページを破棄する仕組みは現状実装されていません。大量のデータを扱う場合、この点がパフォーマンスのボトルネックになる可能性があります。

現時点の判断としては、DartのListで保持しているデータが多すぎるために問題が起きるケースは、相当稀だと考えています。また、AndroidのPaging 3のような実装をライブラリとして提供するためには、DBへの依存を`paging_view`に追加しなければなりません。ただWidgetを表示したいだけなのに、DBに関連する依存が増えるのは避けたいと考えています。^[Flutterの場合、複数のプラットフォームのサポートを考慮すると、どうしてもDBの依存には二の足を踏みます]

現実的には、アプリケーション側で「データそのものは[drift](https://pub.dev/packages/drift)に保存し、`paging_view`の`DataSource`ではIDだけ保持する」といった工夫で回避できると考えています。もしも`paging_view`でメモリ上のデータ量が問題になるケースがあれば、気軽にGitHub Discussionsで相談してください。

### `CustomScrollView.center`プロパティの活用

下方向への読み込みに対して、上方向への読み込みは面倒さが数倍になります。特に、「読み込み前の位置にスクロール位置を固定したまま、その上に要素を追加する」動作を実装するのは大変です。

この動きは`CustomScrollView`の[center](https://api.flutter.dev/flutter/widgets/ScrollView/center.html)プロパティを活用することで実現できます。しかし`center`プロパティには、いくつかの制限があります。例えば、以下のような点です。

* `center`が指定されたSliverの上の要素の上下(左右)が反転する
* `CustomScrollView`に`center`を指定すると同一のkeyを持つSliverが存在しなければならない
* `center`プロパティと対になるSliverは`CustomScrollView`の直下に存在しなければならない

`paging_view`パッケージでは、`CenterPagingList`と名付けたWidgetで、これらの制限を吸収しています。

https://github.com/koji-1009/paging_view/blob/2.6.0/lib/src/widget/center_paging_list.dart

追加読み込みの制御については、先述の`SliverBoundsDetector`を活用しています。このWidgetは任意のSliverの前後に配置するだけで、スクロール位置に応じたコールバックをセットできるため、複数の`SliverList`を組み合わせることができます。

`center`プロパティを活用すると、slivers配列が変化したときに、`center`プロパティに指定されたSliverの位置が維持されます。これを利用し、位置を固定したいSliver(Center用)とPrepend用とAppend用のSliverを分離します。あとはPrependの処理が実行されたら、Prepend用のSliverを更新すれば良いわけです。あらかじめPrependとCenter、Append用に`List<Page>`を用意することで、この処理はシンプルに実装できます。

工夫点としては、AppendやPrependの処理がリクエストされたときに、従来のPrependやAppend用のPageをCenter用のPageにマージする点です。これにより、複数回のAppendやPrependが連続で発生した場合でも、Center用のPageが最新の状態に保たれます。また、このPrependからCenterへのマージ処理と、新たに取得したPrepend用のPageの追加処理は、別のframeで実行される必要があります。現時点では読み込み処理をasync処理にしているため、ValueNotifierの更新を読み込み処理の前後に分けることで、この要件を吸収しています。

なお、現時点ではGridに対応していません。また、Groupedにも対応できていません。もしも気になる方がいれば、IssueやPull Requestを歓迎します。書いてみると、シンプルな実装になるものの、思った以上に手間がかかります。

## おわりに

この記事がきっかけになり、Paging処理に興味を持ってもらえたら嬉しいです。というか、ぜひAndroidのPaging 3のコードを読んでみてほしいです。非常に洗練された設計がなされており、学ぶことが多いと思います。筆者はAndroid Jetpackの中でPagingが一番好きで、`paging_view`パッケージを実装しましたが、Paging 3の凄さは全く模倣できていないと思っています。

今回、記事を書くのに合わせて複数の機能を追加しました。読み込み時にエラーが起きた時リストの状態を保ったまま`SnackBar`を表示できたり、データの再取得なしに未読バッチを更新できたりします。READMEに実装例を追加したので、ぜひ参考にしてください。また、動作に興味を持った方は、サンプルアプリをGitHub Pagesで公開しているので、そちらもご覧ください。

https://github.com/koji-1009/paging_view

デモはこちら。ブラウザで動きます。Flutter Web最高。

https://koji-1009.github.io/paging_view/
