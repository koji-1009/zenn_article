---
title: "Paging処理とFlutter(とpaging_viewパッケージ)"
emoji: "📄"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["flutter", "dart", "paging",]
published: true
published_at: "2025-12-09 07:00"
---

この記事は[Flutter Advent Calendar 2025](https://qiita.com/advent-calendar/2025/flutter)の12月9日分の記事です。

## はじめに

いわゆる無限スクロールについて。アプリを作っていると、誰しも１アプリあたり1~2回は実装する機会があるのではないでしょうか。

しかし、その頻度の割にFlutter公式のWidgetだけで組もうとすると、組めはするものの、しかししっくりこない実装になってしまいがちです。特に追加取得のタイミングや、ややこしいコードを書かざるを得ないことが多い印象です。

本記事では、無限スクロールもといPaging処理の概要を説明します。併せて、筆者が趣味で開発している[paging_view](https://pub.dev/packages/paging_view)パッケージについて紹介することを通して、Flutterにおける柔軟なページング処理について解説します。

## Paging API

十分に大きなデータ、もしくは無限に続くデータを扱う場合、全てのデータを一度に読み込むことは非効率的です。そのため、分割して読み込む必要があります。
特にモバイルアプリケーションでは、ネットワーク帯域やメモリの制約があるため、データを10〜20件づつサーバーから取得することが一般的です。
このような処理では、分割されたデータのことを「ページ」と呼びます。各ページには、通常、固定数のアイテムと次のページを取得するための情報が含まれています。

### Keyのタイプ

Paging APIのkeyは、いくつかのパターンがあります。

一番シンプルなのは、要素の順序をそのまま使うパターンです。1ページ目は要素を追加した順で最初の20、2ページ目は21〜40といった具合です。当然、keyはページ数であり整数値になります。
メリットは実装が簡単な点ですが、リアルタイムで要素の追加や削除が発生するケースでは正しくページングできないデメリットがあります。とはいえ、Google検索のように、順序が変わったとしても許容されるケースでは有効です。

要素に対して一意な値をKeyとして使うケースもあります。読書記録のようなデータであれば、日時をKeyとしても良いでしょう。この場合、APIは「指定した日時よりも新しい/古いデータをN件取得する」といった形になります。一方、いわゆるSNSのタイムラインのようなケースでは、投稿日時をKeyに使うと、同じ日時に複数の投稿がある場合に正しくページングできないデメリットがあります。

これらのメリットとデメリットを整理すると、要素に対して一意なIDを与え、そのIDをKeyとして使うのが最も汎用的です。ページの取得時に、「指定したIDよりも新しい/古いデータをN件取得する」といった形とすることで、リアルタイムで要素の追加や削除が発生しても正しくページングできます。サーバー側で作成日時などの順序を保持した上で、クライアントから渡されたIDを基準に検索する必要があります。

### 追加取得のタイミング

Paging処理では、ユーザーがスクロールしてリストの末尾に近づいたとき、次のページを自動的に取得するケース。もしくは、末尾に次のページの取得をリクエストするボタンなどを設置し、ユーザーが明示的に次のページを取得するケースがあります。いわゆる無限スクロールは前者のケース、後者のケースは「もっと見る」ボタンのケースです。

それぞれのケースにはメリットとデメリットがあります。
自動的に次のページを取得するケースでは、ユーザーはシームレスにコンテンツを閲覧できますが、データ取得が余計に発生するかもしれません。明示的に次のページを取得するケースでは無駄なデータ通信を避けられますが、逐一ボタンをタップするのは不快かもしれません。アプリや機能の性質、想定されるユーザーの行動に応じて、適切な方法を選択することが重要です。

### スクロールのパフォーマンス

ページング処理を行う必要があるのは、大量のデータがある場合です。そもそも、ページング処理を実装するためには、大量のデータをどう扱うかという問題に対処する必要があります。
大量のデータをメモリ上に保持すると、アプリケーションのパフォーマンスが低下し、最悪の場合クラッシュする可能性があります。また、無限に表示される全てのViewをメモリ上に保持すると、同様にパフォーマンスの低下やクラッシュの原因となります。

https://developer.android.com/topic/libraries/architecture/paging/v3-overview?hl=ja

筆者の知る限り、この問題に対して最も洗練された解決策を提供しているのは、AndroidのPaging 3ライブラリです。このライブラリはページごとにデータを読み込むだけでなく、メモリ上に保持する最大ページ数を制御し、それ以上のページをメモリから破棄する仕組みを持っています。さらに、[RemoteMediator](https://developer.android.com/topic/libraries/architecture/paging/v3-network-db?hl=ja)を使って[Room](https://developer.android.com/training/data-storage/room?hl=ja)と連携することで、破棄されたページをローカルデータベースから再取得できます。

Viewにおける工夫は、フレームワークとの協調が必要です。Androidでは[LazyColumn](https://developer.android.com/jetpack/compose/lists?hl=ja#lazy-column)、Flutterでは[SliverList.builder](https://api.flutter.dev/flutter/widgets/SliverList/SliverList.builder.html)など、大量の要素を描画できるWidgetが用意されています。これらのWidgetを適切に利用することで、スクロールパフォーマンスを維持しつつ、大量のデータを効率的に表示できます。

なお、Flutterの`ListView`は`CustomScrollView`と`SliverList`が組み合わさったWidgetです。複数のSliverを組み合わせたい場合には`CustomScrollView`一択になりますが、単にリストを表示したい場合には`ListView`を使う方がシンプルです。しかし、その実態に大きな違いはありません。

## `paging_view`パッケージ

https://pub.dev/packages/paging_view

`paging_view`パッケージは、AndroidのPaging 3っぽい実装を試してみたかった筆者が、趣味で開発しているパッケージです。基本的な考え方はAndroidのPaging 3と似ていますが、`RemoteMediator`のようなローカルデータベースの実現には依存関係が増えてしまうため、あえて実装していません。v2.5.2現在、依存しているパッケージは`flutter`と`collection`のみです。`collection`は`flutter`が依存しているため、実質的には`flutter`のみと言えます。

### 基本的な使い方

`DataSource`クラスを継承し、APIに応じたページング処理を実装します。

https://github.com/koji-1009/paging_view/blob/2.5.2/example/lib/model/data_source_list_repositories.dart#L18-L42

`load`メソッドには、UI操作によって発生するページングの要求が渡されます。`LoadAction`は次の継承クラスを持つ`sealed class`です。

* `Refresh`
* `Prepend(key: final key)`
* `Append(key: final key)`

アクションは「今回どのタイプのリクエストを行うか」と「前回のページングで取得した最後のKey」を含みます。`Refresh`は初回読み込みやリストの更新要求、`Prepend`はリストの先頭方向への追加読み込み、`Append`はリストの末尾方向への追加読み込みです。この`DataSource`を`PagingList`や`SliverPagingList`といったWidgetに渡すことで、Widgetの状態に応じたページング処理が実行されます。

### 設計について

`paging_view`は`ValueNotifier`と`ValueListenableBuilder`、`SliverMainAxisGroup`、そして`RenderSliver`を活用したライブラリです。ここでは、特に`RenderSliver`を活用した部分について説明します。

https://github.com/koji-1009/paging_view/blob/2.5.2/lib/src/private/sliver_bounds_detector.dart

`SliverBoundsDetector`は「`CustomScrollView`の中で描画されるようになる」タイミングで`onVisibilityChanged`コールバックを呼び出すSliverです。[VisibilityDetector](https://pub.dev/packages/visibility_detector)と異なり、`SliverBoundsDetector`は`CustomScrollView`内で[cacheExtent](https://api.flutter.dev/flutter/widgets/ScrollView/cacheExtent.html)を含む領域に入ったタイミングを検出します。このため「そろそろスクロールがリストの末端に届きそう」というタイミングでコールバックを呼び出すことができます。

この`SliverBoundsDetector`を活用することで、ページング処理の実装がシンプルになります。というのも、実態が単なる[LeafRenderObjectWidget](https://api.flutter.dev/flutter/widgets/LeafRenderObjectWidget-class.html)と[RenderSliver](https://api.flutter.dev/flutter/rendering/RenderSliver-class.html)であるため、他のSliverと同様に`CustomScrollView`内で動作するからです。

次のコードは、縦に1行リストを表示する`SliverPagingList`です。

https://github.com/koji-1009/paging_view/blob/2.5.2/lib/src/widget/sliver_paging_list.dart#L230-L276

主な要素を描画する`SliverList.separated`の前後に`SliverBoundsDetector`を配置しています。Sliverの働きにより、リストの先頭や末尾に近づいたタイミングでコールバックが呼び出されます。リストの末尾方向に向かってのリストであれば、このような実装で十分です。^[先頭方向の読み込みについては後述]

### パフォーマンス

Flutterは元々、描画パフォーマンスに優れています。その中でも、特に`CustomScrollView`とSliverの組み合わせは、大量のデータを効率的に表示するための強力なツールです。`paging_view`パッケージは、Flutterのこの特性を最大限に活用しています。

一方で、`paging_view`ではリストの要素をメモリ上に保持しています。AndroidのPaging 3のように、メモリ上に保持するページ数を制御し、不要なページを破棄する仕組みは現状実装されていません。大量のデータを扱う場合、この点がパフォーマンスのボトルネックになる可能性があります。
現時点の判断としては、DartのListで保持しているデータが多すぎるために問題が起きるケースは、エッジケースだと考えています。また、アプリケーション側で「データそのものは[drift](https://pub.dev/packages/drift)に保存し、`paging_view`の`DataSource`ではIDだけ保持する」といった工夫で回避できると考えています。

### `CustomScrollView.center`プロパティの活用

読み込んだ際に「読み込み前の位置にスクロール位置を固定したまま、その上に要素を追加する」動作が、重要になることがあります。この動きは`CustomScrollView`の[center](https://api.flutter.dev/flutter/widgets/ScrollView/center.html)プロパティを活用することで実現できます。しかし、`center`プロパティをセットすると、`center`が指定されたSliverの上の要素の上下(左右)が反転するなど、いくつかの制約があります。また、`center`プロパティと対になるSliverは、`CustomScrollView`の直下に1つだけ配置する必要があります。実装してみると、なかなかに面倒です。

`paging_view`パッケージでは、この機能を組み込んだListを`CenterPagingList`として公開しています。

https://github.com/koji-1009/paging_view/blob/2.6.0/lib/src/widget/center_paging_list.dart

基本的なアイデアは、ページをPrependとCenter、Appendに分離します。そして、`CustomScrollView`の`center`プロパティにCenter用のSliverを指定し、Prepend用とAppend用のSliverをそれぞれ上下(左右)に配置します。これにより、Prepend用のSliverに要素が追加されても、スクロール位置が維持されます。
AppendやPrependが実行されたら、実行されたフレームでPrependやAppendのページをCenterに移動し、次の読み込みに備えます。この手順を繰り返すことで、常にCenterの位置にスクロール位置が維持したまま、要素が追加されます。

と、アイデアを書くだけなら簡単なのですが、実装はなかなかに大変です。このため、現時点ではGridに対応していません。また、Groupedにも対応できてきません。もしも気になる方がいれば、IssueやPull Requestを歓迎します。

## おわりに

この記事がきっかけになり、Paging処理に興味を持ってもらえたら嬉しいです。というか、ぜひAndroidのPaging 3のコードを読んでみてほしいです。非常に洗練された設計がなされており、学ぶことが多いと思います。Paging 3が好きすぎて、Flutterで`DataSource`を描きたいがために、`paging_view`パッケージを実装しました。しかし、Paging 3の凄さは全く実装できていないと思っています。

今回、記事を書くのに合わせて複数の機能を追加しました。読み込み時にエラーが起きた時リストの状態を保ったまま`SnackBar`を表示できたり、データの再取得なしに未読バッチを更新できたりします。READMEに実装例を追加したので、ぜひ参考にしてください。また、動作に興味を持った方は、サンプルアプリをGitHub Pagesで公開しているので、そちらもご覧ください。

https://koji-1009.github.io/paging_view/
